/***************************************************************
               ** File name: hal_entry.c
               ** Created & Modified by: DWC @HET Tech inc
               ** Date: 2021-9-28
 ***************************************************************/
#include "hal_data.h"
#include "hal_entry.h"
#include "pmLib.h"
#include "r_sci_uart.h"
#include "string.h"
#include "math.h"
#include "Photosensitive.h"
//#include "stdio.h"














FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void fKey_Process(void); //T = 2ms 按键处理
void fKey_GetValue(void);  // 获取按键值 
void fDisp_Plungin(void);  //上电显示
void fMotor_Ctrl(void);  // 电机控制
void fDeviceData_Init(void); //设备数据初始化
void fFilter_Cal(void);  //滤网计数相关计算
void fFilter_PercentageCal(void);  //滤网百分比相关计算
void fMemory_Deal(void);  //掉电记忆处理
void fMemory_Read(void);
void fDeviceSys_Init(void);


#define FLASH_DF_BLOCK_0               0x40100000U /*   1 KB: 0x40100000 - 0x401003FF */
#define FLASH_BLOCK0_DATACONFIG_0000			0 //数据配置存储在block0
#define FLASH_BLOCK1_FILTER_4000			1 //滤网相关寿命存储在block1
#define FLASH_BLOCK2_SYSSTATUS_8000			2 //系统相关状态存储在block2
#define FLASH_BLOCK3_PORT1DEVICE_C000			3 //设备相关信息存储在block3
/***************************************************************
                      ** End of hal_entry.c
***************************************************************/

#define FLASH_DATACONFIG_000  	0x40100000U
#define FLASH_DATACONFIG_200		0x40100200U

#define FLASH_FILTER_400  	0x40100400U
#define FLASH_FILTER_600		0x40100600U

#define FLASH_SYSSTATUS_800  	0x40100800U
#define FLASH_SYSSTATUS_A00		0x40100A00U

#define FLASH_PORT1DEVICE_C00  	0x40100C00U
#define FLASH_PORT1DEVICE_E00	0x40100E00U


#define FLASH_CF_BLOCK_10              0x00005000  /*   2 KB: 0x00005000 - 0x000057FF */
#define FLASH_DATA_BLOCK_SIZE          (1024)
#define FLASH_LP_EXAMPLE_WRITE_SIZE    32
#define TRANSFER_LENGTH  50  // 记忆的数据个数


		
		
volatile float Dutyoutput = 2200;
#define  Duty_Limit_min 450
#define  Duty_Limit_max 2600
#define  Duty_outputoff 3000
#define  Duty_start  2200


u8 const sku[16][15]={
"AC1711/10",
"AC1711/20",
"AC1711/21",
"AC1711/30",
"AC1711/90",
"AC1715/10",
"AC1715/11",
"AC1715/20",
"AC1715/21",
"AC1715/30",
"AC1715/40",
"AC1715/60",
"AC1715/70",
"AC1715/80",
"AC1715/00",
"AC1715/85",

};
//桢头 0xfe 0xff  + 数据长度 + 1Port+NData+CRCH+CRCL
u8 const tCommand_Factory[7]= {0xFE,0xFF,0x02,0x01,0x00,0x2E,0x3E};  //闪光灯指令 进入工厂模式
u8 const tCommand_Filtertest[7]= {0xFE,0xFF,0x02,0x06,0x00,0xB7,0xA9}; //闪光灯指令 进入滤网测试
u8 const tCommand_Dataconfig[4]={0xfe,0xff,0x0e,0x03}; //配置指令 前4个字节数据

const u16 tCRC16_caldata[256] =   // crc16 ccitt(0x1021)  init=0xffff  CRC计算数据
{
   0x0000U, 0x1021U, 0x2042U, 0x3063U, 0x4084U, 0x50A5U, 0x60C6U, 0x70E7U,
   0x8108U, 0x9129U, 0xA14AU, 0xB16BU, 0xC18CU, 0xD1ADU, 0xE1CEU, 0xF1EFU,
   0x1231U, 0x0210U, 0x3273U, 0x2252U, 0x52B5U, 0x4294U, 0x72F7U, 0x62D6U,
   0x9339U, 0x8318U, 0xB37BU, 0xA35AU, 0xD3BDU, 0xC39CU, 0xF3FFU, 0xE3DEU,
   0x2462U, 0x3443U, 0x0420U, 0x1401U, 0x64E6U, 0x74C7U, 0x44A4U, 0x5485U,
   0xA56AU, 0xB54BU, 0x8528U, 0x9509U, 0xE5EEU, 0xF5CFU, 0xC5ACU, 0xD58DU,
   0x3653U, 0x2672U, 0x1611U, 0x0630U, 0x76D7U, 0x66F6U, 0x5695U, 0x46B4U,
   0xB75BU, 0xA77AU, 0x9719U, 0x8738U, 0xF7DFU, 0xE7FEU, 0xD79DU, 0xC7BCU,
   0x48C4U, 0x58E5U, 0x6886U, 0x78A7U, 0x0840U, 0x1861U, 0x2802U, 0x3823U,
   0xC9CCU, 0xD9EDU, 0xE98EU, 0xF9AFU, 0x8948U, 0x9969U, 0xA90AU, 0xB92BU,
   0x5AF5U, 0x4AD4U, 0x7AB7U, 0x6A96U, 0x1A71U, 0x0A50U, 0x3A33U, 0x2A12U,
   0xDBFDU, 0xCBDCU, 0xFBBFU, 0xEB9EU, 0x9B79U, 0x8B58U, 0xBB3BU, 0xAB1AU,
   0x6CA6U, 0x7C87U, 0x4CE4U, 0x5CC5U, 0x2C22U, 0x3C03U, 0x0C60U, 0x1C41U,
   0xEDAEU, 0xFD8FU, 0xCDECU, 0xDDCDU, 0xAD2AU, 0xBD0BU, 0x8D68U, 0x9D49U,
   0x7E97U, 0x6EB6U, 0x5ED5U, 0x4EF4U, 0x3E13U, 0x2E32U, 0x1E51U, 0x0E70U,
   0xFF9FU, 0xEFBEU, 0xDFDDU, 0xCFFCU, 0xBF1BU, 0xAF3AU, 0x9F59U, 0x8F78U,
   0x9188U, 0x81A9U, 0xB1CAU, 0xA1EBU, 0xD10CU, 0xC12DU, 0xF14EU, 0xE16FU,
   0x1080U, 0x00A1U, 0x30C2U, 0x20E3U, 0x5004U, 0x4025U, 0x7046U, 0x6067U,
   0x83B9U, 0x9398U, 0xA3FBU, 0xB3DAU, 0xC33DU, 0xD31CU, 0xE37FU, 0xF35EU,
   0x02B1U, 0x1290U, 0x22F3U, 0x32D2U, 0x4235U, 0x5214U, 0x6277U, 0x7256U,
   0xB5EAU, 0xA5CBU, 0x95A8U, 0x8589U, 0xF56EU, 0xE54FU, 0xD52CU, 0xC50DU,
   0x34E2U, 0x24C3U, 0x14A0U, 0x0481U, 0x7466U, 0x6447U, 0x5424U, 0x4405U,
   0xA7DBU, 0xB7FAU, 0x8799U, 0x97B8U, 0xE75FU, 0xF77EU, 0xC71DU, 0xD73CU,
   0x26D3U, 0x36F2U, 0x0691U, 0x16B0U, 0x6657U, 0x7676U, 0x4615U, 0x5634U,
   0xD94CU, 0xC96DU, 0xF90EU, 0xE92FU, 0x99C8U, 0x89E9U, 0xB98AU, 0xA9ABU,
   0x5844U, 0x4865U, 0x7806U, 0x6827U, 0x18C0U, 0x08E1U, 0x3882U, 0x28A3U,
   0xCB7DU, 0xDB5CU, 0xEB3FU, 0xFB1EU, 0x8BF9U, 0x9BD8U, 0xABBBU, 0xBB9AU,
   0x4A75U, 0x5A54U, 0x6A37U, 0x7A16U, 0x0AF1U, 0x1AD0U, 0x2AB3U, 0x3A92U,
   0xFD2EU, 0xED0FU, 0xDD6CU, 0xCD4DU, 0xBDAAU, 0xAD8BU, 0x9DE8U, 0x8DC9U,
   0x7C26U, 0x6C07U, 0x5C64U, 0x4C45U, 0x3CA2U, 0x2C83U, 0x1CE0U, 0x0CC1U,
   0xEF1FU, 0xFF3EU, 0xCF5DU, 0xDF7CU, 0xAF9BU, 0xBFBAU, 0x8FD9U, 0x9FF8U,
   0x6E17U, 0x7E36U, 0x4E55U, 0x5E74U, 0x2E93U, 0x3EB2U, 0x0ED1U, 0x1EF0U
};




u16 tPM25[3][4][2]={   //参数1 market    参数2 AQI level 参数3 就是阈值（档位加的阈值和减的阈值）
{{1,36},{36,76},{76,116},{116,500}},       //pollution market
{{1,13},{13,36},{36,56},{56,500}},   // allergen market
{{1,61},{61,121},{121,251},{251,500}},	//india market
};	//每一区间的高低阈值 LEVEL0 到 LEVEL3

u8 tIAI[4][2]={  //IAI 三个market都一样 所以就只要二维数组就可以了
	{1,4},
	{4,7},
	{7,10},
	{10,12}
};

u16 tAuto_Spd[2][3][4]=  //自动模式下的风速
{
	// 参数1 allergen 或者pillution 可以通过wifi更改 写入E方
	// 参数2 market  可以通过闪光灯标定信息 写入E方
	//参数3 就是AQI level 
	{  // allergen preferred
		{550,1010,1425,2020, } //pollution market
		,{550,1010,1425,2020, } //allergen market
		,{550,1010,1425,2020, } //india market
	},
	{    // pollution  preferred
		{550,1010,1425,2020, }  //pollution market
		,{550,1010,1425,2020, }	//allergen market
		,{550,1010,1425,2020, }	//india market
	}
};

//数码管:正向位置;共阳极;取反连接;带小数点
u8 tLED_Segdata[19]= 
{0xFC,0x60,0xDA,0xF2,0x66,0xB6,0xBE,0xE0,0xFE,0xF6
,0xEE,0x3E,0x9C,0x7A,0x9E,0x8E,0x00,0x02,0xce};//0-9,A-F,灭,-,P
//0-9,A-F,灭;//0-9,A-F,灭,-P
u8 tRxBuffer[RTxData_Max]= {0};  // wifi接收数据缓存 先接收大一点
u8 tTxBuffer[RTxData_Max]= {0};  // wifi接收数据缓存 先接收大一点
//u8       g_dest[TRANSFER_LENGTH]= {0};

u16 tDisp_Buff[6]= {0};  //显示缓存




const Buz_str Buz=   //48Mhz  5ms 计数
{
	{
		{100,200,48000000/4000},
		{0,0,0},
		{0,0,0},
	},  // P_ON

	{
	{100,200,48000000/4000},
		{0,0,0},
		{0,0,0},
	}, //P_Off

	{
		{100,200,48000000/4000},
		{0,0,0},
		{0,0,0},
	}, //P_Once

	{
		{100,200,48000000/4000},
		{100,200,48000000/4000},
		{0,0,0},
	}, //P_Twice

	{
		{100,200,48000000/4000},
		{100,200,48000000/4000},
		{0,0,0},
	}, //P_Succs

	{
		{100,200,48000000/4000},
	{100,200,48000000/4000},
		{0,0,0},
	}, //P_Fail
};

Motor_str Motorpara=  //实际转速  计算方式 频率16Khz 周期数值为
{
	{0, 0,}, //关机时候  全部放大10倍
	{550,550,}, //SLEEP
	{2020,2020,},	//TURBO
	{550, 550,}, //SPD1
	{1010, 1010,},	 //SPD2
	{1425,1425,},	//SPD3
	{0,0,},  //初始化 output
	{0,0,}, //初始化 outputtmp
};

FG_str 			FG;  //风速反馈计算	
Filter_str 		Filter; //滤网状态
DI_str 			DI={0};
Sys_str			Sys;  // 系统标志位等等参数
Particle_str	Particle;  //颗粒物传感器结构体数据
eIDtypedef 		eID_type;
ePortdef 		ePort;
market_t 		market=POLLUTION_MARKET;
Pid_str Pid;




u8 WifiStatutmp[3]={0};  //wifi状态缓存 在滤网测试时候使用


u8 gTime5msflg = 0;  // 5ms定时标志位
u8 gTime100msflg = 0; // 100ms 定时标志位
u8 gTime500msflg = 0; // 100ms 定时标志位

u8 gTime1sflg = 0;	// 1S定时标志位
u8 gFre1hzflashflg = 0;  //1HZ 频率闪烁
u8 gFre0_5hzflashflg = 1;  //0.5HZ
//---------------------按键相关-------------------------------------
u8 volatile KeyStatus = 0;
u8 volatile KeyValue = 0;
u8 volatile keyTemp = 0;

//---------------------蜂鸣器相关-------------------------------------
u8 gBuzEnable = 0;  //蜂鸣器使能
u8 gBuzbeat = 0;  //蜂鸣器的阶段 一般分为三个阶段
u16 gBuzCnt = 0;  //蜂鸣器计数

u8 PcomCnt;  //com口计数 扫描时候使用
//------------------AQI相关-------------------//
u8 gAQIduty_Blue = 100;
u8 gAQIduty_Red = 100;  //颜色占空比

u8 gOnoffstatus = 0; // 全局开关机变量




flash_result_t blank_check_result;







void ffacstart(void)
{
	Sys.Factoryflg = 1; // 进入工厂模式
	//R_ICU_ExternalIrqOpen(&g_external_irq0_ctrl, &g_external_irq0_cfg); //开启外部终端 双沿中断 PM25使用
	//R_ICU_ExternalIrqEnable(&g_external_irq0_ctrl);
	Buz_Twice();
	Sys.wifisetcnt = 0;
}


void fFilterWorkedDataInit(void) // 滤网已经工作的数据复位
{
	Filter.Normalaccumulated_10min = 0;
	Filter.Normalaccumulated_hour = 0; //普通滤网累加计时清除
	Filter.CCMaccumulated_ug = 0; //CCM累加清除
	Filter.CCMcurrent_ug = 0;  //当前CCM值清除
	Filter.CCMaccumulated_ugtmp = 0;//放大80倍之后的累加值
	Filter.CCMremaining_mg = Filter.CCMmgmax_mg; //CCM剩余值就是最大值
	Filter.Time1S_Cnt = 0; //预置滤网计数清除（滤网测试时）
	Filter.Preaccumulated_hour = 0; //预置滤网 （正常运行计数）
}





void fDelay_us(u32 n)
{
	while(n)
	{
		__NOP();
		n--;
	}
}

uint16_t fCRC16_cal(const uint8_t *bytes, unsigned len) // crc16 ccitt(0x1021)  init=0xffff
{
   uint16_t value_ = 0xFFFF; //初始值，根据CRC类型设定

   while(len--)
   {
      value_ = ((value_ << 8) ^ tCRC16_caldata[(uint16_t)((value_ >> 8) ^ *bytes) & 0xFFU]) & 0xFFFFU;

      bytes++;
   }

   return value_;
}

void fhex2chr(u8 *dst,u8 *source,u8 Bytelen)  //默认输出大写字母
{
	u8 i,j =0;
	for (i=0; i<(Bytelen*2);i+=2,j++)
	{
		
		if(((source[i]>>4)&0x0f)<=9)  //高4位
			dst[i]=((source[j]>>4)&0x0f)+0x30;
		else
			dst[i]=((source[j]>>4)&0x0f)+0x37;
		
		if((source[i]&0x0f)<=9)  //低4位
			dst[i+1]=(source[j]&0x0f)+0x30;
		else
			dst[i+1]=(source[j]&0x0f)+0x37;
			
	}
	
}



void fFLASH_WRITE ( u8 const blocks,uint32_t const src_address,uint32_t const num_bytes)
{
 //   uint8_t i;


//    for (uint32_t i = 0; i < TRANSFER_LENGTH; i++)
//    {
//        t_src[i] = (uint8_t) ('A' + (i % 26));
//    }
	uint32_t flash_address;

	flash_address=0x40100000+blocks*1024;
    fsp_err_t err = R_FLASH_LP_Open(&g_flash_ctrl, &g_flash_cfg);
    err = R_FLASH_LP_Erase(&g_flash_ctrl, flash_address, 1);
    err = R_FLASH_LP_BlankCheck(&g_flash_ctrl, flash_address, FLASH_DATA_BLOCK_SIZE, &blank_check_result);
    R_FLASH_LP_Write(&g_flash_ctrl, (uint32_t)src_address, flash_address, num_bytes);
	R_FLASH_LP_Write(&g_flash_ctrl, (uint32_t)src_address, flash_address+512, num_bytes);
    
}



fsp_err_t fFLASH_ERASE ( u8 const blocks)
{
 //   uint8_t i;


//    for (uint32_t i = 0; i < TRANSFER_LENGTH; i++)
//    {
//        t_src[i] = (uint8_t) ('A' + (i % 26));
//    }
	uint32_t flash_address = 0;

	flash_address=0x40100000+blocks*1024;
    fsp_err_t err = R_FLASH_LP_Open(&g_flash_ctrl, &g_flash_cfg);

    err = R_FLASH_LP_Erase(&g_flash_ctrl, flash_address, 1);
    err = R_FLASH_LP_BlankCheck(&g_flash_ctrl, flash_address, FLASH_DATA_BLOCK_SIZE, &blank_check_result);
	return  err;
}





//void ctsu_callback (ctsu_callback_args_t * p_args)
//{
//    if (CTSU_EVENT_SCAN_COMPLETE == p_args->event)
//    {
//        g_scan_flag = true;
//    }
//}
//	void ctsu_basic_example (void)
//	{
//	    fsp_err_t err = FSP_SUCCESS;
//	    uint16_t  data[CTSU_CFG_NUM_SELF_ELEMENTS];
//	//    err = RM_TOUCH_Open(g_qe_touch_instance_config01.p_ctrl, g_qe_touch_instance_config01.p_cfg);
//	    /* Handle any errors. This function should be defined by the user. */
//	//    while (true)
//	//    {
//	//        err = R_CTSU_ScanStart(&g_ctsu_ctrl);
//	//        handle_error(err);
//	//        while (!g_scan_flag)
//	//        {
//	//            /* Wait for scan end callback */
//	//        }
//	//        g_scan_flag = false;
//	//        err = R_CTSU_DataGet(&g_ctsu_ctrl, data);
//	//        if (FSP_SUCCESS == err)
//	//        {
//	//            /* Application specific data processing. */
//	//        }
//	//    }
//	}

	

void fSystem_Init(void)  //系统初始化
{	
	uint32_t volatile  tmp1,tmp2;
	u16 volatile i;
	u8 volatile times= 0;
	u8 volatile Keytemp = 0;
	u8 volatile Keytime = 0;

    R_WDT_Open(&g_wdt_ctrl, &g_wdt_cfg);  // 打开并且初始化看门口 PCLKB=24M  				8192分频  	16384CYCLE 大概5.59S
    R_GPT_Open(&Timer_125us_ctrl,&Timer_125us_cfg);  //打开初始化定时器0模块 125US中断
  
    R_GPT_Open(&g_timer2_ctrl,&g_timer2_cfg);  //定时器模块 1MS
   
    R_GPT_Open(&g_PWM_motor_ctrl,&g_PWM_motor_cfg);   //定时器1作为定时器输出 PWM 初始化0hz 占空比50
   
    
	PWR_BUZ_OFF(); //关闭蜂鸣器
	
	R_GPT_Reset(&g_timer3_ctrl);
	R_GPT_PeriodSet(&g_timer3_ctrl,0);
	R_GPT_DutyCycleSet(&g_timer3_ctrl,0,GPT_IO_PIN_GTIOCA);
	R_GPT_Open(&g_timer3_ctrl,&g_timer3_cfg);   //定时器3作为定时器输出 PWM 初始化1046 占空比50
	R_GPT_OutputDisable(&g_timer3_ctrl, GPT_IO_PIN_GTIOCA);
//    R_GPT_OutputEnable(&g_timer3_ctrl, GPT_IO_PIN_GTIOCA);
	
	
    R_SCI_UART_Open( &g_uart2_ctrl, &g_uart2_cfg);  //初始化串口功能模块
	//R_ICU_ExternalIrqOpen(&g_external_irq0_ctrl, &g_external_irq0_cfg);
	
	R_SCI_UART_Read(&g_uart2_ctrl, &tRxBuffer[0],RTxData_Max);  //该函数的作用是设置读取数据存储的地方，还有限定最大的接收个数
    R_ADC_Open(&g_adc_ctrl, &g_adc_cfg);  //初始化AD模块        AD通道8        LDR检测
    R_ADC_ScanCfg(&g_adc_ctrl, &g_adc_channel_cfg);
    R_ADC_ScanStart(&g_adc_ctrl);

	__enable_irq(); //开启中断
	for(Keytime=0;Keytime<4;Keytime++)  //最多检测4次 可以初始化4次最多
	{
		qe_touch_Init();  // 按键初始化
		fDelay_us(0xff);
		for (i = 0; i < 600; i++)  // 按键设置
		{
			R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
			Keytemp = qe_getvalueInit();
			if(Keytemp != 0 &&i >250)  // 检测到有按键按下    可以判断为误动作  重新初始化 至少要检测0.5S
			{
				break;
			}
		}
		if(Keytemp == 0)  //前面按键都正常
		{
			tmp1 = g_touch_button_reference[0];//+g_touch_button_reference[1]+g_touch_button_reference[2];
			tmp2 = g_touch_button_countvalue[0];//+g_touch_button_countvalue[1]+g_touch_button_countvalue[2];
			if(tmp1<12000 || tmp2<12000) //值不正常直接初始化
			{
				;
			}	
			else
			{
				if((abs(g_touch_button_countvalue[0]-g_touch_button_reference[0]))>=280 && g_touch_button_countvalue[0]>g_touch_button_reference[0])
				{
					;
				}
				else
				{
					break; //上面值出来都没啥问题  可以直接退出4次初始化大循环
				}

			}
		}

		
	}
	
	
	

	for (i = 0; i < 600; i++)  // 按键设置 稳定阶段 这个也是一个保险
	{
		R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
		Keytemp=qe_getvalueInit();
		if(Keytemp!=0 && i>400) // 至少要保持0.8S
		{
			qe_touch_Init();// 初始化
			break;
		}
	}

	

	 __disable_irq(); //清除 PRIMASK 屏蔽所有中断
	R_GPT_Start(&Timer_125us_ctrl);			//启动定时器 125US
	R_GPT_Start(&g_timer2_ctrl);			//1ms
	R_GPT_Start(&g_PWM_motor_ctrl);			//PWM 电机驱动
	R_GPT_OutputEnable(&g_PWM_motor_ctrl, GPT_IO_PIN_GTIOCA);
	R_GPT_Start(&g_timer3_ctrl);
	R_GPT_OutputDisable(&g_timer3_ctrl, GPT_IO_PIN_GTIOCA);
//	R_LVD_Open(&g_lvd_ctrl, &g_lvd_cfg); //开启低电压检测  下降沿有效


//    R_WDT_Refresh(&g_wdt_ctrl);  //WDT 刷新
}

void fPower_On(void)  //开机操作
{

	gOnoffstatus=DI.Port3_air.para2.power = 1;
	Sys.AQI_LEVEL = 0; //aqi 开机初始为0
	Buz_PowerOn();
}

void fPower_Off(void) //关机操作
{
	DI.Port3_air.para2.power= 0;
	if(Sys.Warmup30s_Cnt<=300) //手动关机退出预热功能.
		Sys.Warmup30s_Cnt=301;
	if(gOnoffstatus!=DI.Port3_air.para2.power)
	{
		gOnoffstatus = DI.Port3_air.para2.power;
		Buz_PowerOff();
	}
	
}
//--------------------------------------------------------------
//	不按粉尘传感器的公式来，规格书直接给定时长，需要重新计算
//	↓↓↓↓↓↓↓↓↓作废↓↓↓↓↓↓↓↓↓
//	精度暂定为0.1%，计算的时候放大1000倍，这样1就代表0.1%
//	此处套入公式已经省略，直接用结果做了表格
//	规格书上写的四档分割线是75,150,250
//	TotalTime = X*30000000/125
//	X		Y(LD-3C)	Y(LD-5)	Lo1000	TotalTime       D_vavle(差值)
//	0.016	35.3		23.4		16		3840			3840
//	0.023	49.6		32.9		23		5520			1680
//	0.036	75.0		49.8		36		8640			3120
//	0.049	100.1		66.4		49		11760			3120
//	0.056	113.8		75.5		56		13440			1680
//	0.057	115.7		76.8		57		13680			
//	0.074	151.1		100.3		74		17760			4320
//	0.095	201.5		133.8		95		22800			5040
//	0.104	226.5		150.5		104		24960			2160
//	0.112	250.9		166.7		112		26880			1920
//	0.126	299.2		198.9		126		30240			3360
//	0.145	378.5		251.7		145		34800			4560

//	0.152	413.0		275.0				36480			1680
//	0.160	456.0		303.0				38400			1920
//	0.168	500.0		332.0				40320 			1920



void fCalculate_PM25(u32  PM25_LPO) 
{
	static u8 Index=0;
	u16 Temp = 0;
	if(PM25_LPO<=3840)
	{
		Temp=(u16)(PM25_LPO*353/3840);// 
	} 
	else if(PM25_LPO<=5520)
	{
		PM25_LPO -=3840;
		Temp=(u16)(PM25_LPO*(496-353)/1680+353);//
	} 
	else if(PM25_LPO<=8640)
	{
		PM25_LPO-=5520;					
		Temp=(u16)(PM25_LPO*(750-496)/3120+496);//2.59
	} 
	else if(PM25_LPO<=11760)
	{
		PM25_LPO-=8640;
		Temp=(u16)(PM25_LPO*(1001-750)/3120+750);//2.24
	} 
	else if(PM25_LPO<=13440)
	{
		PM25_LPO-=11760;
		Temp=(u16)(PM25_LPO*(1138-1001)/1680+1001);//4.7
	} 
	else if(PM25_LPO<=17760)
	{
		PM25_LPO-=13440;
		Temp=(u16)(PM25_LPO*(1511-1138)/4320+1138);//4.9
	} 
	else if(PM25_LPO<=22800)
	{
		PM25_LPO-=17760;
		Temp=(u16)(PM25_LPO*(2015-1511)/5040+1511);//5.3
	} 
	else if(PM25_LPO<=24960)
	{
		PM25_LPO-=22800;
		Temp=(u16)(PM25_LPO*(2265-2015)/2160+2015);//6.9
	} 
	else if(PM25_LPO<=26880)
	{
		PM25_LPO-=24960;
		Temp=(u16)(PM25_LPO*(2509-2265)/1920+2265);//6.9
	} 
	else if(PM25_LPO<=30240)
	{
		PM25_LPO-=26880;
		Temp=(u16)(PM25_LPO*(2992-2509)/3360+2509);//6.9
	} 
	else if(PM25_LPO<=34800)
	{
		PM25_LPO-=30240;
		Temp=(u16)(PM25_LPO*(3785-2992)/4560+2992);//6.9
	
	} 
	
	//	0.145	378.5		251.7		145 	34800			4560
	
	//	0.152	413.0		275.0				36480			1680
	//	0.160	456.0		303.0				38400			1920
	//	0.168	500.0		332.0				40320			1920
	else if(PM25_LPO<=36480)
	{
		PM25_LPO-=34800;
		Temp=(u16)(PM25_LPO*(4130-3785)/1680+3785);//6.9
	
	} 

	else if(PM25_LPO<=38400)
	{
		PM25_LPO-=36480;
		Temp=(u16)(PM25_LPO*(4560-4130)/1920+4130);//6.9
	
	} 

	else if(PM25_LPO<=40320)
	{
		PM25_LPO-=38400;
		Temp=(u16)(PM25_LPO*(5000-4560)/1920+4560);//6.9
	
	} 
	else
	{
		Temp = 5000;
	}
	Temp = Temp/10;
	Particle.PM25Total -=Particle.PM25Buf[Index];
	Particle.PM25Buf[Index++] = Temp;
	Particle.PM25Total+=Temp;
	if(Index>=8)
		Index = 0;
	Particle.PM25 = (Particle.PM25Total>>3);
}

void fFactory_ParticleInit(void)
{
//	Particle.Index = 0;
//	Particle.KeepCnt = 10;
	Particle.P1Time = 0;
	Particle.P1TotalTime = 0;
	Particle.PM25 = 0;
	Particle.PM25Total = 0;
//	memset(&Particle.PM25Buf[0],0,sizeof(Particle.PM25Buf));
//	memset(&Particle.P1TBuf[0],0,sizeof(Particle.P1TBuf));
}

void fFactory_ParticleGet(void)
{
	static u8 DustErrCnt = 0;
	//更新数组，并求出数组的和，下面的方法可以提高效率
	//求出P1的值	
	Particle.P1TotalTime = Particle.P1Time*30;//加上新值
	Particle.P1Time = 0;//清零时间	
	fCalculate_PM25(Particle.P1TotalTime);
	if(Particle.PM25>= tPM25[market][Sys.AQI_LEVEL][1])
	{
		if(Sys.AQI_LEVEL<3)
		{
			Sys.AQI_LEVEL++;
		}
		else
		{
			Sys.AQI_LEVEL =3 ;
		}
	}
	else if(Particle.PM25 < tPM25[market][Sys.AQI_LEVEL][0])
	{
		if(Sys.AQI_LEVEL>0)
		{
			Sys.AQI_LEVEL--;
		}
		else
		{
			Sys.AQI_LEVEL = 0;
		}
	}
}

void  fFacmode_Disp_Ctrl(void)
{
	static u8 t_src[8]={0x55,0xfa,0xaa,0xee,0x00,0x00,0x00,0x00}; 
	static u8 Errcode = 0;  //故障代码 E1风机故障 E2颗粒物传感器故障 E3光敏电阻故障 E12 wifi模块未正常
	static u16 errpm25cnt = 0; //PM25传感器检测计数 这边检测电平 所以1ms检测一次
    static u8 delay_3Scnt = 31;  //倒计时三秒
	static u8 datacurrenttmp = 0; //当前数据的缓存值
	static u16 i = 0;
	static u16 tmp = 0;
	static u16 flashcnt = 0;
	static u16 flashpart0 = 0;
	static u16 flashpart1 = 0;
	static u8 sErr_5s = 0;
	static signed long s32_ChangeValue = 0;
	static unsigned long u32_ChangeValue = 0;
//	volatile u32 tmp = 0;
	static u8 Motoroffdelay = 0;  // 电机延时关闭的标志 为0的时候可以直接关闭
	static u8  microsetup = 0;
	static u16 Cnt = 0;
	DI.Port3_air.para5.UIlight = eLightNomal; //UI打开
	Sys.eLight20S_Cnt = 20; // 只要有按键20计时重新计算
	DI.Port3_air.para7.opmode = emodeTurbo;  // 模式设为Turbo
	Sys.wifisetcnt = 0;
	LED_Ring_Dis();     //解决进入自检之后 部分灯光不会清除的问题
	LED_Wifi_Amber_Dis();
	LED_Wifi_White_Dis();
	if((Sys.Errcode&(bit0|bit1))==0) //解决故障状态下LED辉光问题
	{
        switch(Sys.Factorysteps)
        {
            case 0:
                Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
                Motorpara.Spd_Output[1] = Motorpara.Spd_Off[1];
                LED_Filter_En ();
                if(delay_3Scnt==31)
                {
                    fFLASH_WRITE(FLASH_BLOCK1_FILTER_4000,&t_src[0],4); //滤网数据写到FLASH_BLOCK1_FILTER_4000 经常会改变
                }
                else if(delay_3Scnt==0)
                {
                    Sys.Factorysteps = 1;
                }
                break;
            case 1:
                for(i=0; i<4; i++) //获取数据参数
                    {
                            t_src[i+4] = *((uint8_t *)(FLASH_FILTER_400+i));
                    }
                if(memcmp(&t_src[0],&t_src[4],4)==0) //数据参数获取 存储在Block0中
                {
                    if((flashcnt%1000)<500)
                    {
                        LED_Filter_Dis ();
                    }
                    else
                    {
                        LED_Filter_En ();
                    }
                    flashcnt++;
                    if(flashcnt>=3000)
                    {
                        flashcnt = 0;
                        Sys.Factorysteps = 2;
                        LED_Filter_Dis ();
                    }
                }
                else
                {
                    if(gFre1hzflashflg)
                    {
                        LED_Filter_En ();
                    }
                    else
                    {
                        LED_Filter_Dis ();
                    }
                }
                break;
            case 2:
                if(gFre1hzflashflg)  //闪烁显示
                        LED_Wifi_Amber_En();
                    else
                        LED_Wifi_Amber_Dis();

                break;
            case 3:	
                Sys.Wifi_EWS_DONE_flg = 0; // 手动发起配网操作
                Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
                DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
                DI.Port2_wifiu.para3.setup = wifi_S_requested; // 不会进入快速滤网了 把wifi清除 20220216	

                Motorpara.Spd_Output[0] = Motorpara.Spd_Sleep[0];
                Motorpara.Spd_Output[1] = Motorpara.Spd_Sleep[1];
                if(Sys.steadyflg == 1)
                {
                    if(gFre1hzflashflg)
                    {
                        pCom2=0;
                    }
                    else
                    {
                        pCom2=1;
                    }
                }
                else
                {
                    pCom2=0;
                }
                break;
            case 4:
                pCom2=0;pCom4=0;
                Motorpara.Spd_Output[0] = Motorpara.Spd2[0];
                Motorpara.Spd_Output[1] = Motorpara.Spd2[1];
                Sys.Factorysteps = 5;
                
                break;
            case 5:
                if(Sys.steadyflg == 1)
                {
                    if(gFre1hzflashflg)
                    {
                        pCom2=0;pCom4=0;
                    }
                    else
                    {
                        pCom2=1;pCom4=1;
                    }
                }
                else
                {
                    pCom2=0;pCom4=0;
                }
                break;
            case 6:
                Motorpara.Spd_Output[0] = Motorpara.Spd3[0];
                Motorpara.Spd_Output[1] = Motorpara.Spd3[1];
                pCom2=0;pCom3=0;
                Sys.Factorysteps = 7;
                break;
            case 7:
                if(Sys.steadyflg == 1)
                {
                    if(gFre1hzflashflg)
                    {
                        pCom2=0;pCom3=0;
                    }
                    else
                    {
                        pCom2=1;pCom3=1;
                    }
                }
                else
                {
                    pCom2=0;pCom3=0;
                }
                break;
            case 8:
                Motorpara.Spd_Output[0] = Motorpara.Spd_Turbo[0];
                Motorpara.Spd_Output[1] = Motorpara.Spd_Turbo[1];
                pCom2=0;pCom4=0;pCom3=0;
                Sys.Factorysteps = 9;
                break;
            case 9:
                if(Sys.steadyflg == 1)
                {
                    if(gFre1hzflashflg)
                    {
                        pCom2=0;pCom4=0;pCom3=0;
                    }
                    else
                    {
                        pCom2=1;pCom4=1;;pCom3=1;
                    }
                }
                else
                {
                    pCom2=0;pCom4=0;pCom3=0;
                }
                break;
            case 10:
                
                break;
            case 11: //显示SKU
                if(flashcnt>=2000)
                {
                    if((flashcnt%1000)<500)
                    {
                        LED_Ring_Blue_En ();
                    }
                    else
                    {
                        LED_Ring_Blue_Dis ();
                    }
                }
                else
                {
                    if((flashcnt%1000)<500)
                    {
                        LED_Ring_Red_En();
                    }
                    else
                    {
                        LED_Ring_Red_Dis();
                    }
                }
                flashcnt++;
                if(flashcnt>=4000)
                {
                    flashcnt = 0;
                }
                break;
            case 12: //显示版本
                flashpart0 = (DI.Port1_device.para12.node0applicationversion[2]-0x30)*1000;
                flashpart1 = ((DI.Port1_device.para12.node0applicationversion[4]-0x30)+1)*1000+flashpart0;
                if(flashcnt<flashpart0)
                {
                    if((flashcnt%1000)<500)
                    {
                        LED_Ring_Blue_En ();
                    }
                    else
                    {
                        LED_Ring_Blue_Dis ();
                    }
                }
                else
                {
                    if((flashcnt%1000)<500)
                    {
                        LED_Filter_En ();
                    }
                    else
                    {
                        LED_Filter_Dis ();
                    }
                }
                flashcnt++;
                if(flashcnt>=flashpart1)
                {
                    flashcnt = 0;
                }
                break;
            case 13: //复位
    //			fDeviceSys_Init();
    //			fDeviceData_Init();  //设备的一些信息初始化 包括初始化每一个port的数据
    //			DI.Port3_air.para2.power = 0;	
    //			Sys.Wifi_EWS_DONE_flg = 0; // 手动发起配网操作
    //			PWR_WIFI_EN();  // 开启wifi电源
    //			Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
    //			DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
    //			DI.Port2_wifiu.para3.setup = wifi_S_requested;
    //			Sys.wifisetcnt = 0; // 次数清除
    //			Sys.Factoryflg = 0;
                return;
                break;
                
        }
	}
	

	if(Sys.Errcode&bit0)
	{
		LED_Ring_Dis();
		pCom4 = 0;  //风机故障亮RB1
	}
	else if(Sys.Errcode&bit1)
	{
		LED_Ring_Dis();
		pCom3 = 0;  //PM25传感器故障亮RB2
	}

	if(Sys.Factorysteps>=3) //wifi检测在第3步骤时候会开启
	{
		if(Pin_CheckPM25==0) // 每1毫秒检测一次
		{
			if(errpm25cnt>=10000) // 
			{
				errpm25cnt = 0;
			}
			else
			{
				if(++errpm25cnt>=9999) //连续10S均为低电平 则报错
				{
					errpm25cnt = 9999;
					Sys.Errcode |=bit1;	 //PM25传感器有问题	
				}
			}
		}
		else
		{
			if(errpm25cnt<10000)
			{
				errpm25cnt = 10000;
			}
			else
			{
				if(++errpm25cnt>=20000)  //连续10S均为高电平 则报错
				{
					errpm25cnt = 20000;
					Sys.Errcode |=bit1;	 //PM25传感器有问题	
				}
			}
		}
		
		if(Sys.WifiEnable&& Sys.Factorysteps>=3)
		{
			if(Sys.Factorywifisteps == 0)
			{
				DI.Port4_fac.para2.pcba = 1;  //进入工厂模式 首先PCBA产测 置1
				DI.Port4_fac.para3.wifi = 0;  //进入工厂模式
				DI.Port4_fac.para4.reset = 0;  //进入工厂模式 
				Sys.Factorywifisteps = 1; // 产测wifi PCBA
			}
			if(Sys.Factorywifisteps >3) //清0是wifi 检测成功 wifi自己会把该标志位清除
			{
				LED_Wifi_White_En(); //wifi自检成功 白灯常量
				LED_Wifi_Amber_Dis(); // 修复bug 20220216 白灯和橙灯同时亮起的bug
				Sys.Wifi_EWS_DONE_flg = 0; // 手动发起配网操作
				Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
				DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
				DI.Port2_wifiu.para3.setup = wifi_S_requested;	
			}
			else if(Sys.Factorywifisteps >=1) //开始检测wifi
			{
				if(gFre1hzflashflg)  //闪烁显示
					LED_Wifi_Amber_En();
				else
					LED_Wifi_Amber_Dis();
			}
		}
		
	}
//	if(Sys.lightADvalue_10bit<5 ||Sys.lightADvalue_10bit>=1000) //光敏AD值过大或者过小都认为是存在故障 需要保持5S
//	{
//		if(++errlightcnt>=3000) //保持3S 
//			Errcode |= bit2;
//	}
//	else
//	{
//		errlightcnt = 0; //清除
//	}


//	if(LightADtmp!=Sys.lightADvalue_10bit)
//	{
//		LightADtmp=Sys.lightADvalue_10bit;
//		errlightcnt1 = 0;
//	}
//	else
//	{
//		if(++errlightcnt1>=5000)  //连续5S保持不变
//		{
//			errlightcnt1 = 5000;
//			Errcode |= bit2;
//		}
//	}
	if(gTime100msflg&bit2)  //每隔100ms
	{
		gTime100msflg&=~bit2;
		if(delay_3Scnt)
			delay_3Scnt--;
		if(Sys.Factorysteps>=3)
		{
			if(Sys.Errcode== 0 && (Motorpara.Spd_Output[0]!=Motorpara.Spd_Off[0]))  //风机没有故障的情况下
			{
				
				Motoroffdelay = 2;  // 电机可以直接开启
				if(Sys.FanspeedFB<100)  //连续5S风速反馈小于100  报风机故障
				{
					sErr_5s++;
					if(sErr_5s>=50)
					{
						sErr_5s = 50;
						Sys.Errcode |=0x01;  // 5S之内没达到100转
					}
				}
				else   // 风速正常 计数清除
				{
					sErr_5s = 0;		
					if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])<=50)
					{
						Sys.steadycnt++;
						if(Sys.steadycnt>=30)
						{
							Sys.steadycnt = 30;
							Sys.steadyflg = 1;
						}
					}
					else
					{
						Sys.steadycnt = 0;
						Sys.steadyflg = 0;
					}
				}
			}
			else
			{
				if(Motoroffdelay)
					Motoroffdelay--;
				Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];				
			}
			
		}
		

		
	

		if(Motoroffdelay)
		{
			PWR_MOTOR_EN();
		}
		else
		{
			PWR_MOTOR_DIS();
		}
		if(Motorpara.Spd_Output[0]==Motorpara.Spd_Off[0])
		{
			R_GPT_DutyCycleSet(&g_PWM_motor_ctrl, Duty_outputoff,GPT_IO_PIN_GTIOCA);
			Dutyoutput = Duty_start;
			
		}
		else
		{
			if(Sys.FanspeedFB<200)
			{
				Dutyoutput = Duty_start;
			}
			else
			{
				Pid.SpeedFB2 = Pid.SpeedFB1;
				Pid.SpeedFB1 = Sys.FanspeedFB;
				Pid.E_delta = Motorpara.Spd_Output[0] - Sys.FanspeedFB ;
				Pid.E_delta_BIAS = (Pid.SpeedFB1- Pid.SpeedFB2);
				Pid.E_deltasum += Pid.E_delta;
				if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>=200)
				{
					Pid.Kp = 0.02;
				}
				else if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>=100)
				{
					Pid.Kp = 0.015;
				}
				else if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>50)
				{
					Pid.Kp = 0.01;
				}
				else
					Pid.Kp = 0.002;
				Pid.Ki = 0;
				Pid.Kd = 0;
//				Pid.Ki = 0.0001;
	//			Pid.Kd = 0.3;

				if(abs(Pid.E_delta) <=20)
					Pid.Kp = 0;
				Pid.output = Pid.Kp*Pid.E_delta+Pid.E_deltasum*Pid.Ki+ Pid.E_delta_BIAS*Pid.Kd;

				Dutyoutput = Dutyoutput-Pid.output;
//				if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>50)
//					Dutyoutput = Dutyoutput-Pid.output;
//				else
//				{
//					if(Motorpara.Spd_Output[0]==Motorpara.Spd_Sleep[0])
//					{
//						Dutyoutput = 2020;
//					}
//					else if(Motorpara.Spd_Output[0]==Motorpara.Spd2[0])
//					{
//						Dutyoutput = 1560;
//					}
//					else if(Motorpara.Spd_Output[0]==Motorpara.Spd3[0])
//					{
//						Dutyoutput = 1110;
//					}
//					else if(Motorpara.Spd_Output[0]==Motorpara.Spd_Turbo[0])
//					{
//						Dutyoutput = 485;
//					}
//				}
			}
			
			R_GPT_DutyCycleSet(&g_PWM_motor_ctrl, (uint32_t)Dutyoutput,GPT_IO_PIN_GTIOCA);

		}
		
	}
	if(gTime1sflg&bit2)  //每间隔1S钟
	{
		gTime1sflg&=~bit2;
		fFactory_ParticleGet(); //获取PM2.5传感器数值
	
	
	}

	
	
	
	


	
}



void fFactory_Key_Process(void) //T =5ms
{
    u16 dat;
	fKey_GetValue();

	 
	if(KeyStatus & KEY_Available)    //键值有效
	{
	    KeyStatus &= ~KEY_Available; //键值失效
	    Sys.Sleep3S_Cnt = 3;  // 睡眠模式下重新计数
	    dat = KeyValue ;  //取按键值
        if((Sys.Errcode&(bit0|bit1))!=0)
            dat = 0;
	    if(Sys.Factoryflg == 1)
	    {
			 switch(dat)
		    {
			
		    case KEY_MODE:	//模式按键
		        if(KeyStatus & KEY_ShortPress)
		        {
		            KeyStatus&=~KEY_ShortPress;	
		        }

				if(Sys.Factorysteps == 2)
				{
					Sys.Factorysteps = 3;
						Buz_Once();
				}
				else if(Sys.steadyflg && Sys.Factorysteps == 3)
				{
					Sys.steadyflg = 0;
					Sys.steadycnt = 0;
					Sys.Factorysteps = 4;
						Buz_Once();
				}

				else if(Sys.steadyflg && Sys.Factorysteps == 5)
				{
					Sys.steadyflg = 0;
					Sys.steadycnt = 0;
					Sys.Factorysteps = 6;
						Buz_Once();
				}

				else if(Sys.steadyflg && Sys.Factorysteps == 7)
				{
					Sys.steadyflg = 0;
					Sys.steadycnt = 0;
					Sys.Factorysteps = 8;
						Buz_Once();
				}

				else if(Sys.steadyflg && Sys.Factorysteps == 9)
				{
					Sys.steadyflg = 0;
					Sys.steadycnt = 0;
					Sys.Factorysteps = 10;
						Buz_Once();
				}
				else if(Sys.Factorysteps == 10)
				{
					Sys.Factorysteps = 11;
						Buz_Once();
				}
				else if(Sys.Factorysteps == 11)
				{
					Sys.Factorysteps = 12;
						Buz_Once();
				}
				
		        break; 
			 case KEY_POWER:  //
		        if(KeyStatus & KEY_ShortPress) //短按只会执行一次
		        {
		            KeyStatus&=~KEY_ShortPress;
					if(Sys.Factorysteps == 12)
					{
						Sys.Factorysteps = 13;
						fDeviceSys_Init();
						fDeviceData_Init();  //设备的一些信息初始化 包括初始化每一个port的数据
						fMemory_Read(); //确保可以正常读取信息
						DI.Port3_air.para2.power = 0;	
						Sys.Wifi_EWS_DONE_flg = 0; // 手动发起配网操作
						PWR_WIFI_EN();  // 开启wifi电源
						Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
						DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
						DI.Port2_wifiu.para3.setup = wifi_S_requested;
						Sys.wifisetcnt = 0; // 次数清除
						Sys.Factoryflg = 0;
							Buz_Once();
					}
		        }

					if(KeyStatus&KEY_LongOnce)
			        {
			            KeyStatus &=~KEY_LongOnce;
						// if(Sys.Factorysteps <=2) //取消进入自检
						// {
						// 	Sys.Factorysteps = 13;
						// 	Sys.wifisetcnt = 0; // 次数清除
						// 	Sys.Factoryflg = 0;
						// 	if(Sys.FilterTestFlg == 0)
						// 	{
						// 		DI.Port3_air.para2.power = 1;  //滤网测试模式 开机
						// 		Sys.FilterTestFlg = 1; // 滤网测试模式
						// 		PWR_WIFI_EN();  // 开启wifi电源
						// 		Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
						// 		fDeviceSys_Init(); //系统参数初始化
								
						// 		Buz_Twice();	
						// 	}
						// }
			        }
				break;
		   		
				
		    default	:
		        break;
		    }
	    }
		else
		{
			 switch(dat)
		    {

			 case KEY_POWER:  //
		        if(KeyStatus & KEY_ShortPress) //短按只会执行一次
		        {
		            KeyStatus&=~KEY_ShortPress;
					
		        }

		        break;
		    case KEY_MODE:	//模式按键
		        if(KeyStatus & KEY_ShortPress)
		        {
		            KeyStatus&=~KEY_ShortPress;
					
		        }

		        break; 
		   
		    default	:
		        break;
		    }
		}
	   
	}

//	if(KeyStatus & KEY_Release)
//	{
//	    KeyStatus &=~KEY_Release;
//	}
 
}

void fKey_GetValue(void)  //获取键值并处理
{
    static u8 status = 0;	//状态变量：0检测是否有键按下，1滤波延时，2等待放开并判断是否长按，3长按等待放开
    static u16 temp1,temp2;
    static u16 counter = 0;
    static u8 counter1 = 0;
    static u8 Counter_Unlike = 0;  //键值不相等滤波
	keyTemp = qe_getvalue();
	if(Pin_CheckKEY==0)
		keyTemp |= 0x02;
	else
		keyTemp &=~0x02;
    switch (status)
    {
    case 0:										//扫描按键 检测是否有按下
        temp1 = keyTemp;
        if(!temp1)				//没有键按下
        {
			KeyStatus |= KEY_Release;			//按键放开
            break;
        }
        status = 1;				//有键按下
        break;
    case 1:																			//有键按下后进行计时
        temp2 = keyTemp;
        if(temp1 == temp2)									//判断是否是相同按键还在按下
        {
			KeyStatus &= ~KEY_Release;		//按键未放开
            counter++;
            if (counter >= KEY_FILTER_COUNT)	//消抖完成
            {
                counter = 0;
                status = 2;											//切换到等待放开状态
 //               KeyValue = temp2;
//                KeyStatus |= KEY_Available;	//键值有效
//                KeyStatus |= KEY_ShortPress;  //按下直接响应

            }
        }
        else																//不是同一按键或没有键按下
        {
			KeyStatus |= KEY_Release;			//按键放开
            status = 0;												//判定为抖动，键值判断完成
            counter = 0;
        }
        break;
    case 2:																		//等待放开并判断是否长按
        if(temp2 == keyTemp)							//按键没有放开
        {
            Counter_Unlike = 0;
            counter1=0;
            counter++;											//等待按键放开的计时
			 KeyStatus &= ~KEY_Release;		//按键未放开
			if (counter >= KEY_LONG_COUNT)	//达到长按时间长度
            {
                counter = 0;
                KeyValue = temp2;							//长按按键值
                KeyStatus |= KEY_Available;	//键值有效
                KeyStatus |= KEY_LongPress;	//长按标志置位
                KeyStatus |= KEY_LongOnce;  //长按一次标志置位
                status = 3;										//切换到长按等待放开状态
            }
        }
        else															//按键已经放开
        {
            counter = 0;
            if(keyTemp !=0)  //按键值不相等
            {
				KeyStatus &= ~KEY_Release;		//按键未放开
                counter1= 0;
                Counter_Unlike++;
                if(Counter_Unlike>=KEY_PULSE_FILTER_COUNT)
                {
                    Counter_Unlike = 0;
                    status = 0;
                }
            }
            else
            {
                Counter_Unlike = 0;
                counter1++;
                if(counter1>=KEY_PULSE_FILTER_COUNT)
                {
                    counter1=0;
                    KeyValue = temp2;
                    KeyStatus |= KEY_Available;		//键值有效
                    KeyStatus &= ~KEY_LongPress;		//长按标志清零
                    KeyStatus &= ~KEY_LongOnce; // 2019.07.24 将长按一次的标志位和长按标志位同时清除
                    KeyStatus |= KEY_ShortPress;  // 2021.06.29 放开才会响应
                    KeyStatus |= KEY_Release;			//按键放开
                    status = 0;
                }
            }//键值判断完成
        }
        break;
    case 3:																		//长按等待放开状态
        if(temp2 == keyTemp)										//按键没有放开
        {
            counter1=0;
            Counter_Unlike = 0;
            counter++;											//长按保持的计时
            KeyStatus &= ~KEY_Release;		//按键未放开
            if (counter >= KEY_KEEP_COUNT)	//长按保持计时完成
            {

                counter = 0;
                KeyStatus |= KEY_Available;		//键值有效
                KeyStatus |= KEY_LongPress;		//长按标志
            }
        }
        else															//按键已经放开
        {
            counter = 0;
            if(keyTemp !=0)
            {
                counter1= 0;
                Counter_Unlike++;
				KeyStatus &= ~KEY_Release;		//按键未放开
                if(Counter_Unlike >= KEY_PULSE_FILTER_COUNT)
                {
                    Counter_Unlike = 0;
                    status = 0;
                }
            }
            else
            {
                Counter_Unlike = 0;
                counter1++;
                if(counter1>=KEY_PULSE_FILTER_COUNT)
                {
                    counter1=0;
                    KeyStatus &= ~KEY_Available;		//键值无效
                    KeyStatus &= ~KEY_LongPress;		//长按标志清零
                    KeyStatus &= ~KEY_LongOnce; // 2019.07.24 将长按一次的标志位和长按标志位同时清除
                    KeyStatus |= KEY_Release;			//按键放开
                    status = 0;
                }
            }//键值判断完成
        }
        break;
    default:
        status = 0;
        break;
    }
}

void fKey_Process(void) //T =5ms
{
    u16 dat = 0;	
	static volatile u8 Filter_rstcnt =0;
	static volatile u8 Fac_testcnt = 0;
	fKey_GetValue();
	if(keyTemp!=KEY_MODE)
		Filter_rstcnt = 0;
	if(keyTemp!=KEY_POWER_MODE)
		Fac_testcnt = 0;
	if(KeyStatus & KEY_Available)    //键值有效
	{
	    KeyStatus &= ~KEY_Available; //键值失效

		if(Sys.Setupflg<2)  // 未设置机型 或者处于刚配置完成状态
			return;
	    	   		
		if(Sys.Errcode&bit0) //电机故障E1
	  		dat = 0;
	 	 else
	    	dat = KeyValue ;  //取按键值
		if(DI.Port3_air.para2.power)  //开机条件下
	    {
			if(DI.Port3_air.para7.opmode == emodeSleep) //睡眠模式
		    {
				if(Sys.Sleep3S_Cnt==0) // 睡眠模式下处于睡眠状态
				{
					if(dat!=0x02)
					{
						dat = 0; //这边保证按键无响应
						KeyStatus =0; //保证不会响应
					}
				}
				Sys.Sleep3S_Cnt = 3;  // 这里唤醒机器进入三秒倒计时
				Sys.eLight20S_Cnt = 20; // 只要有按键20计时重新计算
		    }
//			if(DI.Port3_air.para5.UIlight !=eLightNomal && dat!=KEY_LIGHT)
//			{
//				if(DI.Port3_air.para5.UIlight == eLightoff) // 在关闭的情况下 第一次唤醒.
//				{
//					dat = 0; //这边保证按键无响应
//					KeyStatus =0; //保证不会响应
//				}
//				DI.Port3_air.para5.UIlight = eLightNomal;
//				Sys.eLight20S_Cnt = 20; // 只要有按键20计时重新计算
//			}
	    }
		if(dat != 0)
		{
			Sys.eLight20S_Cnt = 20; // 只要有按键20计时重新计算
		}
	    switch(dat)
	    {
		 case KEY_POWER:  //开关按键
	        if(KeyStatus & KEY_ShortPress) //短按只会执行一次
	        {
	            KeyStatus&=~KEY_ShortPress;
				
				if(!DI.Port3_air.para2.power)
					fPower_On();
				else
					fPower_Off();
	        }

			if(KeyStatus&KEY_LongOnce)
	        {
	            KeyStatus &=~KEY_LongOnce;
				if(Sys.Errcode&bit4) // F2报警 滤网时间耗尽 机器锁
					break;
				if(DI.Port3_air.para2.power&&Sys.WifiEnable)
				{
					Sys.Wifi_EWS_DONE_flg = 0; // 手动发起配网操作
					PWR_WIFI_EN();  // 开启wifi电源
					Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
					DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
					DI.Port2_wifiu.para3.setup = wifi_S_requested;
					Sys.wifisetcnt = 0; // 次数清除
					Buz_Once();
				}
	        }
	        break;
	    case KEY_MODE:	//模式按键
	        if(KeyStatus & KEY_ShortPress)
	        {
	            KeyStatus&=~KEY_ShortPress;
				if(Sys.Errcode&bit4) // F2报警 滤网时间耗尽 机器锁
					break;
				if(DI.Port3_air.para2.power)
				{
					switch(DI.Port3_air.para7.opmode)
					{
						case emodeAuto:
							DI.Port3_air.para7.opmode = emodeTurbo;
							break;
						
						case emodeTurbo:
							DI.Port3_air.para7.opmode = emodeSleep;
							break;
						case emodeSleep:
							DI.Port3_air.para7.opmode = emodeAuto;
							break;
						default:
							DI.Port3_air.para7.opmode = emodeAuto;
							break;
					}
					Buz_Once();
				}
	        }

			if(KeyStatus&KEY_LongPress)
	        {
	            KeyStatus &=~KEY_LongPress;
				if(Filter.Normalaccumulated_hour<(Filter.NormalLifemaxhour*97/100))
				{
				
					if(Sys.Plugin_Cnt<150) //上电10秒之内 按按键 连续5S才能进入 所以最多就是15S.
					{
						Filter_rstcnt++;
						if(Filter_rstcnt>=5) // 0.5*4+1*3
						{
							Filter_rstcnt = 0;
							Filter.Normalaccumulated_hour = 0; //普通滤网累加计时清除
							Filter.Normalaccumulated_10min = 0; // 累计清除
							Filter.Forcereset_3S_Cnt=30;
							if(Sys.FilterTestFlg == 0) //非滤网测试时候
							Filter.Storeflg = 1;  //需要存进E方
							Buz_Once();
					
						}
					}
	       	 }
			}
			
			if(KeyStatus&KEY_LongOnce)
			{
				KeyStatus &=~KEY_LongOnce;  // 只会执行一次
				if(Filter.Normalaccumulated_hour>= (Filter.NormalLifemaxhour*97/100))  //普通滤网开始报警 
				{
					Filter.Normalaccumulated_hour = 0; //普通滤网累加计时清除
					Filter.Normalaccumulated_10min = 0; // 累计清除
//					Filter.CCMaccumulated_ug = 0; //CCM累加清除
//					Filter.CCMcurrent_ug = 0;  //当前CCM值清除
//					Filter.CCMaccumulated_ugtmp = 0;//放大80倍之后的累加值
//					Filter.CCMremaining_mg = Filter.CCMmgmax_mg; //将最大值赋予
					if(Sys.FilterTestFlg == 0) //非滤网测试时候
						Filter.Storeflg = 1;  //需要存进E方
					Buz_Once();
				}
			}
	        break; 

		 case KEY_POWER_MODE:  // 组合按键  进入工厂模式或者
			
				if(KeyStatus&KEY_LongPress)
		        {
		            KeyStatus &=~KEY_LongPress;
					if(Sys.Plugin_Cnt<150)  //上电15秒之内才能执行
					{
						if(KeyStatus&KEY_LongOnce)
						{
							Fac_testcnt++;
							if(Fac_testcnt>=2)
							{
								Fac_testcnt = 0;
								KeyStatus &=~KEY_LongOnce;  // 只会执行一次
								if(Sys.Factoryflg == 0)
								{
									ffacstart();
								}
							}
						}
						
							
							
					}
	       		 }
	        break;
		
	    default	:
	        break;
	    }
	}

 
}













void fParticleGet(void) //获取微粒传感器数据
{
	u16 volatile PM25value = 0;
	u8 volatile IAQLvalue = 0;
	#if PM25LIB
	{
		static u8 sWarmsteps = 0;
		static u8 s1S__cnt = 0;
//		if(Sys.Errcode&(bit0|bit4)||Sys.Setupflg<2)  //风机故障 或者 锁机的情况下
//		{
//			PWR_PM25_DIS(); // 关闭PM25传感器
//			sWarmsteps = 0;
//			s1S__cnt = 0;
//			return;
//		}
		if(DI.Port3_air.para2.power == 1)
		{
			s1S__cnt = 0;
			sWarmsteps = 0;
			PWR_PM25_EN();
			pmCalculate();  // PM2.5传感器使用 per1S 或者IAI	
			IAQLvalue=pmGetIAIValue(MODE_GENERAL, DDP_IAI_LEVEL);
			PM25value=pmGetPM25Value();
			if(PM25value>=400)
				PM25value = 500;
			if(PM25value ==0)
				PM25value = 1;
			else
				DI.Port3_air.para10.pm25 = PM25value;
			if(IAQLvalue == 0)
				IAQLvalue = 1;
			else
				DI.Port3_air.para9.iaql =IAQLvalue;
			if(Sys.Warmup30s_Cnt<=300) // 开机预热30秒内
				return;
			
			if(DI.Port3_air.para15.ddp == eddpIAI)
			{
				
				if(DI.Port3_air.para9.iaql >= tIAI[Sys.AQI_LEVEL][1])
				{
					if(Sys.AQI_LEVEL<3)
					{
						Sys.AQI_LEVEL++;
					}
					else
					{
						Sys.AQI_LEVEL =3 ;
					}
				}
				else if(DI.Port3_air.para9.iaql < tIAI[Sys.AQI_LEVEL][0])
				{
					if(Sys.AQI_LEVEL>0)
					{
						Sys.AQI_LEVEL--;
					}
					else
					{
						Sys.AQI_LEVEL = 0;
					}
				}
			}
			else
			{
				if(DI.Port3_air.para10.pm25 >= tPM25[market][Sys.AQI_LEVEL][1])
				{
					if(Sys.AQI_LEVEL<3)
					{
						Sys.AQI_LEVEL++;
					}
					else
					{
						Sys.AQI_LEVEL =3 ;
					}
				}
				else if(DI.Port3_air.para10.pm25 < tPM25[market][Sys.AQI_LEVEL][0])
				{
					if(Sys.AQI_LEVEL>0)
					{
						Sys.AQI_LEVEL--;
					}
					else
					{
						Sys.AQI_LEVEL = 0;
					}
				}
				
			}

		
		}
		else //standby
		{
			
			switch (sWarmsteps)
			{
				case 0:
					PWR_PM25_EN();
					pmCalculate();  // PM2.5传感器使用 per1S 或者IAI	
					IAQLvalue=pmGetIAIValue(MODE_GENERAL, DDP_IAI_LEVEL);
					PM25value=pmGetPM25Value();
					if(PM25value>=400)
						PM25value = 500;
					if(PM25value ==0)
						PM25value = 1;
					else
						DI.Port3_air.para10.pm25 = PM25value;
					if(IAQLvalue == 0)
						IAQLvalue = 1;
					else
						DI.Port3_air.para9.iaql = IAQLvalue;	
					
					if(s1S__cnt>=30)
					{
						sWarmsteps = 1;
						s1S__cnt = 0;
					}
					s1S__cnt++;
					break;
				case 1:
					PWR_PM25_DIS();
					IAQLvalue=pmGetIAIValue(MODE_GENERAL, DDP_IAI_LEVEL);
					PM25value=pmGetPM25Value();
					if(PM25value>=400)
						PM25value = 500;
					if(s1S__cnt>=180)
					{
						sWarmsteps = 0;
						s1S__cnt = 0;
					}
					s1S__cnt++;
					break;

			}
		}
	}
	#else
	{
		static u8 DustErrCnt = 0;
		if(DI.Port3_air.para2.power == 0)//关机时不作处理
		{
			fFactory_ParticleInit();  //开机之后复位
			return;//因为关机后灰尘传感器会断电
		}

	
		//更新数组，并求出数组的和，下面的方法可以提高效率
		//求出P1的值
		Particle.P1TotalTime -= Particle.P1TBuf[Particle.Index];//减去旧值
		if(Pin_CheckPWRPM25)
		{
			Particle.P1TBuf[Particle.Index] = 0;//重新赋值
		}
		else
		{
			Particle.P1TBuf[Particle.Index] = Particle.P1Time;//重新赋值
		}
		Particle.P1TotalTime += Particle.P1TBuf[Particle.Index];//加上新值
		Particle.P1Time = 0;//清零时间

		

		if(++Particle.Index >= 30)//循环计数
			Particle.Index = 0;

	//	if(Sys.Warmup30s_Cnt<=300)  //初始40S  不判断灰尘传感器的等级
//		{
//			return;
//		}

//		if(!Err.B.Dust) //故障之后无需再进行检测
//		{
//			if((Particle.P1TotalTime > 150000)||(Particle.P1TotalTime == 0))
//			{
//				if(DustErrCnt < (SelfTest?30:120) ) //两分钟 延长时间
//					DustErrCnt++;
//				else
//					Err.B.Dust= 1;
//			}
//			else
//			{
//				DustErrCnt = 0;
//			}
//		}
		fCalculate_PM25(Particle.P1TotalTime);
	}

	
	Particle.P1_Up2sCnt++;
	{
		if(Particle.P1_Up2sCnt>=10)
		{
			Particle.P1_Up2sCnt = 10;
			if(DI.Port3_air.para10.pm25 >= tPM25[market][Sys.AQI_LEVEL][1])
				{
					if(Sys.AQI_LEVEL<3)
					{
						Sys.AQI_LEVEL++;
						Particle.P1_Up2sCnt = 0;
					}
					else
					{
						Sys.AQI_LEVEL =3 ;
					}
				}
				else if(DI.Port3_air.para10.pm25 <= tPM25[market][Sys.AQI_LEVEL][0])
				{
					if(Sys.AQI_LEVEL>0)
					{
						Sys.AQI_LEVEL--;
						Particle.P1_Up2sCnt = 0;
					}
					else
					{
						Sys.AQI_LEVEL = 0;
					}
				}
			
		}
	}
	#endif
//	
	

}


void fBuz_Driver(u8 state)
{
	
	Buzbeatdef* P=&Buz.Sound_On; //声明一个指针 指向Buz的第一个Beat数组
	if(gBuzEnable)
	{
		R_GPT_OutputEnable(&g_timer3_ctrl, GPT_IO_PIN_GTIOCA);
		gBuzCnt++;
		P +=state;
		if(gBuzbeat==0)  //第0阶段
		{
			if(gBuzCnt<P->sta0.Beep_Dur)
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, P->sta0.Freq);
				R_GPT_DutyCycleSet(&g_timer3_ctrl, ((P->sta0.Freq)>>1),GPT_IO_PIN_GTIOCA);
			}
//			if(gBuzCnt<P->sta0.Beep_Dur)
//				PWR_BUZ_ON();   //打开蜂鸣器开关
//			else if(gBuzCnt<P->sta0.Chime_Due)
//				PWR_BUZ_OFF(); //关闭蜂鸣器
			else
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, 0);
				R_GPT_DutyCycleSet(&g_timer3_ctrl,0,GPT_IO_PIN_GTIOCA);
				gBuzbeat = 1;
				gBuzCnt = 0;
			}
		}
		else if(gBuzbeat==1)  //第二阶段
		{
			if(gBuzCnt<P->sta1.Beep_Dur)
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, P->sta1.Freq);
				R_GPT_DutyCycleSet(&g_timer3_ctrl, ((P->sta1.Freq)>>1),GPT_IO_PIN_GTIOCA);
			}
//			if(gBuzCnt<P->sta1.Beep_Dur)
//				PWR_BUZ_ON();   //打开蜂鸣器开关
//			else if(gBuzCnt<P->sta1.Chime_Due)
//				PWR_BUZ_OFF(); //关闭蜂鸣器
			else
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, 0);
				R_GPT_DutyCycleSet(&g_timer3_ctrl,0,GPT_IO_PIN_GTIOCA);
				gBuzbeat = 2;
				gBuzCnt = 0;
			}
		}
		else if(gBuzbeat==2)
		{
			if(gBuzCnt<P->sta2.Beep_Dur)
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, P->sta2.Freq);
				R_GPT_DutyCycleSet(&g_timer3_ctrl, ((P->sta2.Freq)>>1),GPT_IO_PIN_GTIOCA);
			}
//			if(gBuzCnt<P->sta2.Beep_Dur)
//				PWR_BUZ_ON();   //打开蜂鸣器开关
//			else if(gBuzCnt<P->sta2.Chime_Due)
//				PWR_BUZ_OFF(); //关闭蜂鸣器
			else
			{
				R_GPT_PeriodSet(&g_timer3_ctrl, 0);
				R_GPT_DutyCycleSet(&g_timer3_ctrl,0,GPT_IO_PIN_GTIOCA);
				gBuzbeat = 3;
				gBuzCnt = 0;
				gBuzEnable = 0;
			}
		}
	}
	else
	{
		gBuzbeat = 0;
		gBuzCnt = 0;
		R_GPT_Reset(&g_timer3_ctrl);
		R_GPT_PeriodSet(&g_timer3_ctrl, 0);
		R_GPT_DutyCycleSet(&g_timer3_ctrl,0,GPT_IO_PIN_GTIOCA);
		R_GPT_OutputDisable(&g_timer3_ctrl, GPT_IO_PIN_GTIOCA);
//		PWR_BUZ_OFF(); //关闭蜂鸣器
	}
	
}


void fDisp_LedDriver(void)
{
    static uint8_t Duty_Cnt =0;
	static u8 s_Dim1_Cnt=0;
	volatile u16 gAQIduty_Bluetmp = 0;
	volatile u16 gAQIduty_Redtmp = 0;
    static u16 flashcnt = 0;
    static u8 cnt = 0;
	if(Sys.Factoryflg == 0) //非工厂模式下
         LED_Ring_Dis();
if(Sys.Setupflg == 1 &&Sys.Factoryflg==0 ) // 非工厂模式下  天瑞写入配置信息之后可以闪烁显示国家信息.
{
    if(++cnt>=8)
    {
        cnt = 0;
        if(flashcnt>=2000)
        {
            if((flashcnt%1000)<500)
            {
                LED_Ring_Blue_En ();
            }
            else
            {
                LED_Ring_Blue_Dis ();
            }
        }
        else
        {
            if((flashcnt%1000)<500)
            {
                LED_Ring_Red_En();
            }
            else
            {
                LED_Ring_Red_Dis();
            }
        }
        flashcnt++;
        if(flashcnt>=4000)
        {
            flashcnt = 0;
        }
    }
    return;
}
//------------------------AQI驱动--------------------------
	if(Sys.decoring==edeco_Pink)  //粉色显示
	{
	    switch(Sys.AQI_LEVEL)
	    {
	    case 0:
	        gAQIduty_Blue = 100;
	        gAQIduty_Red  = 0;
	        break;
	  	 case 1:
	        gAQIduty_Blue = 35;
	        gAQIduty_Red  = 25;
	        break;
	    case 2:
	        gAQIduty_Blue = 20;
	        gAQIduty_Red  = 100;
	        break;
	    case 3:
	        gAQIduty_Blue = 0;
	        gAQIduty_Red  = 100;
	        break;
		 case 4:
	        gAQIduty_Blue = 0;
	        gAQIduty_Red  = 0;
	        break;

	    }
	}
	else  //其他正常颜色
	{
		switch(Sys.AQI_LEVEL)
	    {
	    case 0:
	        gAQIduty_Blue = 100;
	        gAQIduty_Red  = 0;
	        break;
	    case 1:
	        gAQIduty_Blue = 35;
	        gAQIduty_Red  = 25;
	        break;
	    case 2:
	        gAQIduty_Blue = 20;
	        gAQIduty_Red  = 100;
	        break;
	    case 3:
	        gAQIduty_Blue = 0;
	        gAQIduty_Red  = 100;
	        break;
		 case 4:
	        gAQIduty_Blue = 0;
	        gAQIduty_Red  = 0;
	        break;

	    }
	}
	gAQIduty_Bluetmp = gAQIduty_Blue;
	gAQIduty_Redtmp = gAQIduty_Red;
	if(Sys.Factorysteps==10&&Sys.Factoryflg) // 在产测第十步会显示AQI指数
	{
		 if(++Duty_Cnt>=100)  // 一个周期完成 DIM需要在完整周期时候调整 不然怕混色不均匀
	    {
	        Duty_Cnt = 0;
	    }
		if(Duty_Cnt<=gAQIduty_Redtmp&&gAQIduty_Redtmp>0) //占空比计数时间大于0 并且小于等于所占比例数的时候，开启相应的灯光
	    {			
	        LED_Ring_Red_En();  //两色灯的红色 高电平导通  和 PM25 IAI红灯刚好相反
	    }
 
    	if(Duty_Cnt<=gAQIduty_Bluetmp&&gAQIduty_Bluetmp>0) //同上面红色 下面的蓝色做出不同混合颜色
	    {
	       LED_Ring_Blue_En();  //两色灯的蓝色 高电平导通  和 PM25 IAI蓝灯刚好相反			
	    }	
	}
	if(Sys.Factoryflg)  //工厂产测模式
	{
		return;
	}
   	else
   	{
		if(Sys.Plugin_Cnt>30)  //开机三秒之内不限这些东西
		{
			if(Sys.Setupflg<2)
			{
				LED_Ring_Dis();
				pCom2 = 0;  //RB3亮
				return;
			}
			else if(Sys.Errcode&(bit4)) //滤网时间到锁机器
			{
				LED_Ring_Dis();
				return;
			}
			else if(Sys.Errcode&(bit0)) //故障停机 bit0 风机故障
			{
				LED_Ring_Dis();
				pCom4 = 0;  //风机故障亮RB1
				return;
			}
			else if(DI.Port3_air.para2.power==0) //关机下不显示
			{ //待机条件下（开头3秒需要全量） 或者睡眠模式下3秒显示结束 或者灯光模式关闭 或者机器上锁（滤网时间工作满，达到100%）

				LED_Ring_Dis();
				return;
			}
		}
		if(DI.Port3_air.para7.opmode == emodeAuto) //自动模式60%亮度
		{
			gAQIduty_Bluetmp = gAQIduty_Bluetmp*5;
			gAQIduty_Bluetmp = gAQIduty_Bluetmp/10;
			gAQIduty_Redtmp = gAQIduty_Redtmp*5;
			gAQIduty_Redtmp = gAQIduty_Redtmp/10;
		}
		else if(Sys.Sleep3S_Cnt>0 &&(DI.Port3_air.para7.opmode==emodeSleep)) //睡眠模式下 优先级最高
		{
			gAQIduty_Bluetmp = gAQIduty_Bluetmp*2;
			gAQIduty_Bluetmp = gAQIduty_Bluetmp/10;
			gAQIduty_Redtmp = gAQIduty_Redtmp*2;
			gAQIduty_Redtmp = gAQIduty_Redtmp/10;
		}
		else if(Sys.Sleep3S_Cnt==0 &&(DI.Port3_air.para7.opmode==emodeSleep)) //睡眠模式下 优先级最高
		{
			gAQIduty_Bluetmp = gAQIduty_Bluetmp*5;
			gAQIduty_Bluetmp = gAQIduty_Bluetmp/100;
			gAQIduty_Redtmp = gAQIduty_Redtmp*5;
			gAQIduty_Redtmp = gAQIduty_Redtmp/100;
		}

		if(Sys.FilterTestFlg&&gFre0_5hzflashflg)
		{
			gAQIduty_Bluetmp = 0;
			gAQIduty_Redtmp = 0;
		}
		
	    if(++Duty_Cnt>=100)  // 一个周期完成 DIM需要在完整周期时候调整 不然怕混色不均匀
	    {
	        Duty_Cnt = 0;
	    }
		if(Duty_Cnt<=gAQIduty_Redtmp&&gAQIduty_Redtmp>0) //占空比计数时间大于0 并且小于等于所占比例数的时候，开启相应的灯光
	    {			
	        LED_Ring_Red_En();  //两色灯的红色 高电平导通  和 PM25 IAI红灯刚好相反
	    }
 
    	if(Duty_Cnt<=gAQIduty_Bluetmp&&gAQIduty_Bluetmp>0) //同上面红色 下面的蓝色做出不同混合颜色
	    {
	       LED_Ring_Blue_En();  //两色灯的蓝色 高电平导通  和 PM25 IAI蓝灯刚好相反			
	    }		

   	}
	
}




void  fDisp_Ctrl(void) //显示控制
{
	static u8 sdathcnt=0;
	static u8 sDim_Cnt = 0;
	

	LED_Wifi_Amber_Dis();
	LED_Wifi_White_Dis();
	LED_Filter_Dis();




	if(Sys.Plugin_Cnt<=30) //上电3秒之内全量
	{
		fDisp_Plungin();
		return;
	}

		if(Sys.Setupflg==1) //当闪光灯信息配置刚写入 未断电时只会显示闪光灯数据的累加校验和
		{
			return;
		}

	if(DI.Port3_air.para2.power)
	{	

		if(Sys.WifiEnable)
		{
			if(gFre1hzflashflg)
			{
				if(DI.Port2_wifiu.para2.connection==wifi_C_not_connected)
				{
					if(DI.Port2_wifiu.para3.setup==wifi_S_requested ||DI.Port2_wifiu.para3.setup==wifi_S_active)
						LED_Wifi_Amber_En();
				}

				if(DI.Port2_wifiu.para2.connection==wifi_C_connecting)
				{
					if(DI.Port2_wifiu.para3.setup==wifi_S_active ||DI.Port2_wifiu.para3.setup==wifi_S_inactive)
						LED_Wifi_White_En();
				}
			}

			if(DI.Port2_wifiu.para2.connection==wifi_C_connected)
			{
				if(DI.Port2_wifiu.para3.setup==wifi_S_active)
					LED_Wifi_Amber_En();
			}

			if(DI.Port2_wifiu.para2.connection==wifi_C_connected)
			{
				if(DI.Port2_wifiu.para3.setup==wifi_S_inactive)
				{
					if(Sys.WifiCommtimeoutcnt<=30) // 只有再连续有通讯的时候才会正常显示灯
						LED_Wifi_White_En();
					if(Sys.Wifi_EWS_DONE_flg==0)  //联网成功
						Sys.Wifi_EWS_DONE_flg = 1;
				}
			}
		}
		
			
		
		


		if(Sys.Warmup30s_Cnt<=300)  //开机30S时间内的显示
		{
//			if(((Sys.Warmup30s_Cnt%10)==0) && gTime100msflg&bit0 && Sys.Warmup30s_Cnt>0)
//			{
//				sdathcnt++;
//				if(sdathcnt>=3)
//				{
//					sdathcnt = 0;
//				}
//			}
//			if (((Sys.Warmup30s_Cnt%20)==0) && gTime100msflg&bit0 && Sys.Warmup30s_Cnt>0 )
//			{
//				Sys.AQI_LEVEL++;	
//				if(Sys.AQI_LEVEL>=4)
//					Sys.AQI_LEVEL = 0;
//			}
			Sys.AQI_LEVEL = 0;

			if(gTime100msflg&bit0)
				gTime100msflg&=~bit0;
			
			if(Sys.Warmup30s_Cnt==300) //防止30秒之后 停在红色灯处  都从蓝灯开始
				Sys.AQI_LEVEL = 0;
		}

		if(Filter.Normalaccumulated_hour>=Filter.NormalLifemaxhour) //滤网时间到达 锁机器显示
		{
//			memset(&tDisp_Buff[0],0,sizeof(tDisp_Buff)); //所有的数据先清除
			if(gFre1hzflashflg)  // 正常情况下除了三个按键灯常亮 滤网灯闪烁 其他
				LED_Filter_En();

		}
		else if(Filter.Normalaccumulated_hour>= (Filter.NormalLifemaxhour*97/100))
		{
			LED_Filter_En();
		}

		if(Filter.Forcereset_3S_Cnt>0) // 强制清除的时候 闪烁3次 1HZ
		{
			if(Filter.Forcereset_3S_Cnt%10>=5)
			{
				LED_Filter_En();
			}
			else
			{
				LED_Filter_Dis();
			}
		}
		if(Sys.Sleep3S_Cnt==0 &&(DI.Port3_air.para7.opmode==emodeSleep)) //睡眠模式下 优先级最高
		{
			memset(&tDisp_Buff[0],0,sizeof(tDisp_Buff)); //所有的数据先清除

		}
		else if(DI.Port3_air.para5.UIlight==eLightDim) //处于暗状态
		{
			;
		}
		else if(DI.Port3_air.para5.UIlight==eLightoff) //处于灯光关闭状态
		{
			memset(&tDisp_Buff[0],0,sizeof(tDisp_Buff)); //所有的数据先清除
		}		
	}
	


	if(Sys.FilterTestFlg)  //滤网测试模式的时候
	{
		if(gFre0_5hzflashflg)  //0.5HZ 闪烁显示 
		{
			;
		}
		
	}
	if(Sys.Errcode&bit0) //电机故障 E1
	{

		DI.Port3_air.para2.power = 0;
		
	}
	sDim_Cnt++;
	if(sDim_Cnt>=4)
		sDim_Cnt = 0;
}

void fDisp_Plungin(void)  //上电显示
{
	LED_Wifi_Amber_En();
	LED_Wifi_White_En();
	LED_Filter_En();

	if(Sys.Plugin_Cnt<4)
	{
		Sys.AQI_LEVEL = 3;
	} 
	else if(Sys.Plugin_Cnt<8)
	{
		Sys.AQI_LEVEL = 2;
	}
	else if(Sys.Plugin_Cnt<12)
	{
		Sys.AQI_LEVEL = 1;
	}
	else if(Sys.Plugin_Cnt<16)
	{
		Sys.AQI_LEVEL = 0;
	}
	else if(Sys.Plugin_Cnt<20)
	{
		Sys.AQI_LEVEL = 3;
	} 
	else if(Sys.Plugin_Cnt<24)
	{
		Sys.AQI_LEVEL = 2;
	}
	else if(Sys.Plugin_Cnt<28)
	{
		Sys.AQI_LEVEL = 1;
	}
	else if(Sys.Plugin_Cnt<30)
	{
		Sys.AQI_LEVEL = 0;
	}

}



// u16 spd11 = 2020;

void fMotor_Ctrl(void)
{
	static signed long s32_ChangeValue = 0;
	static unsigned long u32_ChangeValue = 0;
	volatile u32 tmp = 0;
	static u8 Motoroffdelay = 0;  // 电机延时关闭的标志 为0的时候可以直接关闭
	static u8  microsetup = 0;
	static u8  microsetup1 = 0;
	static u16 sErr_5s=0;
	static u8 Cnt0 = 0;
    static u8 Cnt1 = 0;
	if(Sys.Factoryflg) // 产测模式下返回
		return;
	if(Sys.Errcode&(bit0|bit4)||Sys.motorpwmoutput==0)  //风机故障 或者 锁机的情况下
	{
		if(Motoroffdelay)
			Motoroffdelay--; //到0的时候可以直接关闭
		Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
	}
	else
	{
		if(DI.Port3_air.para2.power)  //开机状态下
		{
			Motoroffdelay = 2;  // 电机可以直接开启
			if(Sys.FanspeedFB<100)  //连续5S风速反馈小于100  报风机故障
			{
				sErr_5s++;
				if(sErr_5s>=300)
				{
					sErr_5s = 300;
					Sys.Errcode |=0x01;  // 5S之内没达到100转
				}
			}
			else   // 风速正常 计数清除
				sErr_5s = 0;

			
			switch (DI.Port3_air.para7.opmode)
			{
				case emodeAuto:	
					#ifdef JD  // 京东款子自动模式下的控制逻辑
					static u16 sCalcnt = 0;
					if(Sys.Warmup30s_Cnt<=300)  //预热30S期间 风速保持最低风速
					{
						Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][0];
					}
					else
					{
						switch (Sys.AQI_LEVEL)
						{
							case 0:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][0];
								break;
							case 1:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][1];
								break;
							case 2:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][2];
								break;
							case 3:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][3];
								break;						
						}

						
						if(DI.Port3_air.para10.pm25<=24)
						{
							if(++sCalcnt>=60)
							{
								sCalcnt = 60;
								
							}
							else if(sCalcnt<60)
							{
								sCalcnt = 0;
							}
							
						}
						if(DI.Port3_air.para10.pm25>35)
						{
							sCalcnt = 0;
						}
						if(sCalcnt==60)  // 停机
							Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
					}
					
						
					
					#else
					if(Sys.Warmup30s_Cnt<=300)  //预热30S之内风速保持最低挡位
					{
						Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][0];
					}
					else
					{
						switch (Sys.AQI_LEVEL)
						{
							case 0:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][0];
								break;
							case 1:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][1];
								break;
							case 2:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][2];
								break;
							case 3:
								Motorpara.Spd_Output[0] = tAuto_Spd[DI.Port3_air.para6.userautomodesetting][market][3];
								break;						
						}
					}
					#endif
					
					
					
					break;
				case emodeTurbo:
					Motorpara.Spd_Output[0] = Motorpara.Spd_Turbo[0];
					break;
				case emodeSleep:
					Motorpara.Spd_Output[0] = Motorpara.Spd_Sleep[0];
					break;
				default:
					Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
					break;
				
			}
		}
		else
		{
			if(Motoroffdelay)
				Motoroffdelay--;
			Motorpara.Spd_Output[0] = Motorpara.Spd_Off[0];
			sErr_5s = 0;
			
		}
	}
	


	DI.Port3_air.para8.fanspeed = espdOff;
	if(Motorpara.Spd_Output[0]==Motorpara.Spd_Off[0])
		DI.Port3_air.para8.fanspeed = espdOff;
	else if(Motorpara.Spd_Output[0]==Motorpara.Spd_Sleep[0]) //
		DI.Port3_air.para8.fanspeed = espdSleep;
	else if(Motorpara.Spd_Output[0]==Motorpara.Spd_Turbo[0]) //
		DI.Port3_air.para8.fanspeed = espdTurbo;
	else if(Motorpara.Spd_Output[0]==Motorpara.Spd1[0]) //
		DI.Port3_air.para8.fanspeed = espd1;
	else if(Motorpara.Spd_Output[0]==Motorpara.Spd2[0]) //
		DI.Port3_air.para8.fanspeed = espd2;
	else if(Motorpara.Spd_Output[0]==Motorpara.Spd3[0]) //
		DI.Port3_air.para8.fanspeed = espd3;

	if(Motorpara.Spd_Output[0]==Motorpara.Spd_Sleep[0])  //风速一档和睡眠档位一样
	{
		if(DI.Port3_air.para7.opmode == emodeSleep)
		{
			DI.Port3_air.para8.fanspeed = espdSleep;
		}
		else
		{
			DI.Port3_air.para8.fanspeed = espd1;
		}
	}

	if(Motoroffdelay)
	{
		PWR_MOTOR_EN();
	}
	else
	{
		PWR_MOTOR_DIS();
	}
	if(Motorpara.Spd_Output[0]==Motorpara.Spd_Off[0])
	{
		R_GPT_DutyCycleSet(&g_PWM_motor_ctrl,Duty_outputoff,GPT_IO_PIN_GTIOCA);
		Dutyoutput = Duty_start;
		
	}
	else
	{
		// Motorpara.Spd_Output[0] = spd11;
		if(Sys.FanspeedFB<200)
		{
			Dutyoutput = Duty_start;
		}
		else
		{
			Pid.E_delta = Motorpara.Spd_Output[0]-Sys.FanspeedFB;
            if(abs(Pid.E_delta) <=20)
            {
                if(++Cnt0>=10)
                {
                    Cnt0 = 10;
                    Sys.steadyflg = 1;   //已经保持稳定
                }
                
            }
            else
                Cnt0 = 0;

            if(abs(Pid.E_delta) >=30)
            {
                 if(++Cnt1>=10)
                {
                    Cnt1 = 10;
                    Sys.steadyflg = 0; //不稳定了
                }
            }
            else
                Cnt1 = 0;
			if(++microsetup>=5)
			{
				microsetup = 0;
				if(Sys.steadyflg==0)
				{
				
					if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>=350) //切换档位
					{
						if(Motorpara.Spd_Output[0] == 2020)
						{				
							if(Pid.E_delta>0) //加速
							{
								Dutyoutput -= 120;
							}

							else
								Dutyoutput += 120;	
						}
						else if(Motorpara.Spd_Output[0] ==1425)
						{
							if(Pid.E_delta>0) //加速
							{
								Dutyoutput -= 100;
							}
								
							else
								Dutyoutput += 80;
						}
						else if(Motorpara.Spd_Output[0] == 1010)
						{
							if(Pid.E_delta>0)  //加速
							{
								Dutyoutput -= 100;
							}
							else
								Dutyoutput += 80;
							
						}
						else if(Motorpara.Spd_Output[0] == 550)
						{
							if(Pid.E_delta>0) //加速
								Dutyoutput -= 80;
							else
								Dutyoutput += 60;
						}
							
					}
					// else if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>=200)
					// {
					// 	if(Pid.E_delta>0)
					// 		Dutyoutput-=30;
					// 	else
					// 		Dutyoutput+=30;
							
					// }
					else if(abs(Sys.FanspeedFB-Motorpara.Spd_Output[0])>=100)
					{
						if(Pid.E_delta>0)
							Dutyoutput-=12;
						else
							Dutyoutput+=12;
							
					}
					else
					{
						if(++microsetup1>=10)
						{
							microsetup1 = 0;
							if(Pid.E_delta>0)
							{
								if(Pid.E_delta>80)
									Dutyoutput-=15;
								else if(Pid.E_delta>40)
									Dutyoutput-=10;
								else
								{
                                   
                                     Dutyoutput-=4;
								}
							}
							else if(Pid.E_delta<0)
							{
								if(Pid.E_delta<-80)
									Dutyoutput+=15;
								else if(Pid.E_delta<-40)
									Dutyoutput+=10;
								else 
								{
                                     Dutyoutput+=4;
								}
									
							}
						}
					}
						
				}
				
				
			
				if(Dutyoutput<=Duty_Limit_min)
					Dutyoutput = Duty_Limit_min;
				else if(Dutyoutput>=Duty_Limit_max)
					Dutyoutput = Duty_Limit_max;
				
			}
		}
		
//		FG.delta_speed= abs(Motorpara.Spd_Output[0]-Sys.FanspeedFB);
//		
//			if(Motorpara.Spd_Output[0]>=Sys.FanspeedFB)
//			{
//				if(FG.delta_speed>400)
//				{
//					Dutyoutput-=8;
//				}
//				else if(FG.delta_speed>250)
//				{
//					Dutyoutput-=6;
//				}
//				else if(FG.delta_speed>150)
//				{
//					Dutyoutput-=4;
//				}
//				if(FG.delta_speed>50)
//				{
//					microsetup++;
//					if(microsetup>=5)
//					{
//						microsetup = 0;
//						Dutyoutput-=2;
//					}
//					
//				}
//				else if(FG.delta_speed>18)
//				{
//					microsetup++;
//					if(microsetup>=40)
//					{
//						microsetup = 0;
//						Dutyoutput-=1;
//					}
//				}
//			}
//			else
//			{
//				if(FG.delta_speed>400)
//				{
//					Dutyoutput+=8;
//				}
//				else if(FG.delta_speed>250)
//				{
//					Dutyoutput+=6;
//				}
//				else if(FG.delta_speed>150)
//				{
//					Dutyoutput+=4;
//				}
//				if(FG.delta_speed>50)
//				{
//					microsetup++;
//					if(microsetup>=5)
//					{
//						microsetup = 0;
//						Dutyoutput+=2;
//					}
//					
//				}
//				else if(FG.delta_speed>18)
//				{
//					microsetup++;
//					if(microsetup>=40)
//					{
//						microsetup = 0;
//						Dutyoutput+=1;
//					}
//				}
//					
//				
//				
//			}

//			if(Dutyoutput<=Duty_Limit_min)
//				Dutyoutput = Duty_Limit_min;
//			if(Dutyoutput>=Duty_Limit_max)
//				Dutyoutput = Duty_Limit_max;
//		R_GPT_PeriodSet(&g_PWM_motor_ctrl, 3000);
        if(Sys.motorpwmoutput==0)
 	        Dutyoutput = Duty_outputoff;    
        R_GPT_DutyCycleSet(&g_PWM_motor_ctrl, (uint32_t)Dutyoutput,GPT_IO_PIN_GTIOCA);
	}
	
}


void fMemory_Deal(void)  //掉电记忆处理
{

	static u8 sEepWritedevice;
	static u8 sEepWritesys;
	u8 i = 0;
	u16 volatile datatmp = 0;
	u8 t_src[50] = {0};
	if(Sys.Factoryflg || Sys.FilterTestFlg||Sys.Setupflg!=2) //工厂模式和滤网测试模式下面不进行记忆数据 未配置信息不进行数据存储
		return;
	if(Filter.Storeflg)  //滤网掉电记忆
	{
		Filter.Storeflg = 0;
	
		memset(&t_src[0],0,sizeof(t_src));
		t_src[i++] = 0xfe;
		t_src[i++] = 0xff;
		t_src[i++] = 0x2;
		memcpy(&t_src[i],&Filter.Normalaccumulated_10min,2);

		datatmp=fCRC16_cal(&t_src[i], 2);
		i+=2;
		t_src[i++] = datatmp>>8;
		t_src[i++] = datatmp&0xff;
		
		fFLASH_WRITE(FLASH_BLOCK1_FILTER_4000,&t_src[0],i); //滤网数据写到FLASH_BLOCK1_FILTER_4000 经常会改变	
		return;
	}
	
	memset(&t_src[0],0,sizeof(t_src));
	i = 0;
	t_src[i++] = 0xfe;
	t_src[i++] = 0xff;
	t_src[i++] = DI.Port1_device.para3.Lenths +DI.Port1_device.para10.Lenths+4;
	memcpy(&t_src[i],&DI.Port1_device.para3.Props,DI.Port1_device.para3.Lenths+2);
	i+=DI.Port1_device.para3.Lenths+2;
	memcpy(&t_src[i],&DI.Port1_device.para10.Props,DI.Port1_device.para10.Lenths+2);
	i+=DI.Port1_device.para10.Lenths+2;
	datatmp=fCRC16_cal(&t_src[3], t_src[2]);
	t_src[i++] = datatmp>>8;
	t_src[i++] = datatmp&0xff;
	if(memcmp(((uint8_t *)(FLASH_PORT1DEVICE_C00)),&t_src[0],i)!=0 && memcmp(((uint8_t *)(FLASH_PORT1DEVICE_E00)),&t_src[0],i)!=0)
	{
		if(++sEepWritedevice>=50)
		{
			sEepWritedevice = 0;		
			fFLASH_WRITE(FLASH_BLOCK3_PORT1DEVICE_C000,&t_src[0],i); //device数据写入FLASH_BLOCK3_PORT1DEVICE_C000 不太会改变
			return;
		}	
	}
	else
		sEepWritedevice = 0;
	
	memset(&t_src[0],0,sizeof(t_src));
	i = 0;
//	Sys.IAQL_memvalue = DI.Port3_air.para9.iaql;
//	Sys.PM25_memvalue = DI.Port3_air.para10.pm25; //掉电之前记忆当前数据
	t_src[i++] = 0xfe;
	t_src[i++] = 0xff;
	i++;// 
	t_src[i++] = Sys.wifisetcnt; // wifi配置次数
	t_src[i++] = Sys.Wifi_EWS_DONE_flg; //wifi使用
	t_src[i++] = DI.Port3_air.para2.power;
	t_src[i++] = DI.Port3_air.para17.aqit;
	t_src[i++] = Sys.IAQL_memvalue; //IAI的当前值
	t_src[i++] = (Sys.PM25_memvalue>>8)&0xff; //PM25的当前值 MSB
	t_src[i++] = Sys.PM25_memvalue&0xff; //PM25的当前值 LSB
	t_src[i++] = DI.Port3_air.para3.childLock;
	t_src[i++] = DI.Port3_air.para4.AQILight;
	t_src[i++] = DI.Port3_air.para5.UIlight;
	t_src[i++] = DI.Port3_air.para6.userautomodesetting;
	t_src[i++] = DI.Port3_air.para7.opmode;
	t_src[i++] = DI.Port3_air.para15.ddp;
	
	t_src[2] = i-3; // 待记忆实体个数  
	datatmp=fCRC16_cal(&t_src[3], t_src[2]);
	t_src[i++] = datatmp>>8;
	t_src[i++] = datatmp&0xff;
	if(memcmp(((uint8_t *)(FLASH_SYSSTATUS_800)),&t_src[0],i)!=0 && memcmp(((uint8_t *)(FLASH_SYSSTATUS_A00)),&t_src[0],i)!=0)
	{
		if((++sEepWritesys>=50 ) || DI.Port3_air.para2.power==0) //关机下立马记忆
		{
			sEepWritesys = 0;
			i = 0;
			Sys.IAQL_memvalue = DI.Port3_air.para9.iaql;
			Sys.PM25_memvalue = DI.Port3_air.para10.pm25; //掉电之前记忆当前数据
			t_src[i++] = 0xfe;
			t_src[i++] = 0xff;
			i++;// 
			t_src[i++] = Sys.wifisetcnt; // wifi配置次数
			t_src[i++] = Sys.Wifi_EWS_DONE_flg; //wifi使用
			t_src[i++] = DI.Port3_air.para2.power;
			t_src[i++] = DI.Port3_air.para17.aqit;
			t_src[i++] = Sys.IAQL_memvalue; //IAI的当前值
			t_src[i++] = (Sys.PM25_memvalue>>8)&0xff; //PM25的当前值 MSB
			t_src[i++] = Sys.PM25_memvalue&0xff; //PM25的当前值 LSB
			t_src[i++] = DI.Port3_air.para3.childLock;
			t_src[i++] = DI.Port3_air.para4.AQILight;
			t_src[i++] = DI.Port3_air.para5.UIlight;
			t_src[i++] = DI.Port3_air.para6.userautomodesetting;
			t_src[i++] = DI.Port3_air.para7.opmode;
			t_src[i++] = DI.Port3_air.para15.ddp;
			t_src[2] = i-3; // 待记忆实体个数  
			datatmp=fCRC16_cal(&t_src[3], t_src[2]);
			t_src[i++] = datatmp>>8;
			t_src[i++] = datatmp&0xff;
			fFLASH_WRITE(FLASH_BLOCK2_SYSSTATUS_8000,&t_src[0],i); //系统数据写入FLASH_BLOCK2_SYSSTATUS_8000  经常改变
		}
	}
	else
		sEepWritesys = 0;
	
}

void fMemory_Read(void)
{
	u32 Addr = 0;
	u8 i =0;
	u8 tTmp[50]={0}; //申请50个临时变量用于存储E方中读取的数据
	u16 datatmp = 0; 
	u8 datalen = 0;
	
//---------------------获取配置信息信息-----------------------------	
	Addr = FLASH_DATACONFIG_000;
	do
	{
		memset(&tTmp[0],0,sizeof(tTmp)); //缓存数据数组清除
		for(i=0; i<20; i++) //获取数据参数
	    {
	        tTmp[i] = *((uint8_t *)(Addr+i));
	    }
		Addr+=512;
		if(memcmp(&tTmp[0],&tCommand_Dataconfig[0],4)==0) //数据参数获取 存储在Block0中
		{
			datatmp=fCRC16_cal(&tTmp[3], tTmp[2]);  //计算校验和
			if(datatmp == ((tTmp[tTmp[2]+3]<<8)|tTmp[tTmp[2]+4])) //CRC
			{
				fhex2chr(&DI.Port1_device.para5.ctn[2], &tTmp[4], 2);  //获取CTN;
				fhex2chr(&DI.Port1_device.para5.ctn[7], &tTmp[6], 1);  //获取CTN;
//				for(i=0; i<16; i++) //获取数据参数
//				{
//					if(memcmp(&DI.Port1_device.para5.ctn[0],&sku[i][0],9) == 0)
//					{
//						switch(i)
//						{
//							case 0:
//							case 5:
//							case 6:
//								DI.Port1_device.paraA.area = eAREA_EU;
//								break;
//							case 1:
//							case 7:
//								DI.Port1_device.paraA.area = eAREA_ASEAN;
//								break;
//							case 2:
//							case 8:
//								DI.Port1_device.paraA.area = eAREA_TH;
//								break;
//							case 3:
//							case 9:
//								DI.Port1_device.paraA.area = eAREA_UK_HK;
//								break;
//							case 4:
//								DI.Port1_device.paraA.area = eAREA_MET;
//								break;
//							case 10:
//								DI.Port1_device.paraA.area = eAREA_LAT;
//								break;
//							case 11:
//								DI.Port1_device.paraA.area = eAREA_INDIA;
//								break;
//							case 12:
//								DI.Port1_device.paraA.area = eAREA_ANZ;
//								break;
//							case 13:
//								DI.Port1_device.paraA.area = eAREA_CN_TW;
//								break;
//							case 14:
//								DI.Port1_device.paraA.area = eAREA_CN;
//								break;
//							case 15:
//								DI.Port1_device.paraA.area = eAREA_JAPAN;
//								break;
//								
//								
//						}
//						break;
//					}
//				}
				if(tTmp[7]&bit0)
				{
					market =INDIA_MARKET;
				}
				else
				{
					if(tTmp[7]&bit4)
						market = ALLERGEN_MARKET; //
					else
						market = POLLUTION_MARKET; //
				}
				if(tTmp[7]&bit1)
					DI.Port3_air.para6.userautomodesetting = 1;// Pollution	
				else
					DI.Port3_air.para6.userautomodesetting = 0; //ALLERGEN

				if(tTmp[7]&bit2)
					DI.Port3_air.para15.ddp = eddpPM25; //PM25
				else
					DI.Port3_air.para15.ddp = eddpIAI;// IAI
				DI.Port3_air.para16.rddp = DI.Port3_air.para15.ddp;
	//			if(tTmp[7]&bit3)
	//				Sys.decoring = edeco_Pink; //选择粉色
	//			else
	//				Sys.decoring = edeco_Normal;//选择正常颜色

				

				if(tTmp[7]&bit5)
				{
					Sys.WifiEnable = 1; // 开启wifi功能
				}
				else
				{
					Sys.WifiEnable = 0; //关闭wifi功能
				}

				
				if(tTmp[7]&bit6)
					Sys.Economic = 1; // 开启jd ECONOMIC
				else
					Sys.Economic = 0; //关闭
				
				if(tTmp[7]&bit7) //最小使用年限
					Filter.NormalLifeloweresthour = 2400*2;  //1年
				else
					Filter.NormalLifeloweresthour = 2400*1;	//半年

				Motorpara.Spd_Turbo[1]	=	tTmp[8]*10;  //改变turbo 速度 10倍
				Motorpara.Spd_Turbo[0] = Motorpara.Spd_Turbo[1];  //风速控制用的值先放大10倍
				Filter.NormalLifemaxhour = ((tTmp[9]>>5)+ 1)*2400;  //最大使用年限 N个半年 
				Filter.CCMmgmax_mg= 4000* (tTmp[9]&0x1f);  //单位是毫克

				DI.Port1_device.paraA.area =tTmp[10];
				DI.Port1_device.paraB.color =tTmp[11];
				Sys.PM25_TFa = (signed int)(tTmp[12]<<8)+(signed int)tTmp[13];
				Sys.PM25_TFb = (signed int)(tTmp[14]<<8)+(signed int)tTmp[15];
				Sys.Setupflg = 2; // 配置成功 处于用户模式 断过电了

				
				Motorpara.Spd_Sleep[1]	=	tTmp[16]*10;  //改变Sleep 速度 10倍
				Motorpara.Spd_Sleep[0] = Motorpara.Spd_Sleep[1];  //风速控制用的值先放大10倍
				tAuto_Spd[DI.Port3_air.para6.userautomodesetting][0][0] = Motorpara.Spd_Sleep[1];
				tAuto_Spd[DI.Port3_air.para6.userautomodesetting][1][0] = Motorpara.Spd_Sleep[1];
				tAuto_Spd[DI.Port3_air.para6.userautomodesetting][2][0] = Motorpara.Spd_Sleep[1];
//				if(DI.Port3_air.para6.userautomodesetting==1) // pollution prefer
//				{
//					tAuto_Spd[DI.Port3_air.para6.userautomodesetting][0][0] = Motorpara.Spd_Sleep[1];
//					tAuto_Spd[DI.Port3_air.para6.userautomodesetting][1][0] = Motorpara.Spd_Sleep[1];
//					tAuto_Spd[DI.Port3_air.para6.userautomodesetting][2][0] = Motorpara.Spd_Sleep[1];
//				}
				Sys.checksumOption = 0;
				for(i=4;i<(tTmp[2]+3);i++) //计算有效数据的累加和
				{
					Sys.checksumOption += tTmp[i];
				}
				Sys.checksumOption&=0x00ff;
				break;
			}
		}
		
	}
	while (Addr<=FLASH_DATACONFIG_200);
	
//	market = ALLERGEN_MARKET; //
//	DI.Port3_air.para6.userautomodesetting = 0; //ALLERGEN

//	Sys.Setupflg = 2;
//	Motorpara.Spd_Turbo[0] = 2020;
//	Motorpara.Spd_Turbo[1] = 2020;
	if(Sys.WifiEnable)
	{
		PWR_WIFI_EN(); // 开启wifi电源 进行配网
	}
	else
	{
		PWR_WIFI_DIS(); // 关闭wifi电源
		Sys.Wifi_EWS_DONE_flg = 0;
		Sys.wifisetcnt = 0;
	}
	if(Sys.Setupflg<2) //只有配置过过电
	{
		Buz_Once();  //响一声
		return;
	}

	if(Sys.Factoryflg ||Sys.FilterTestFlg)  //当处于测试模式的时候  无需进行数据读取 因为都已经清除了
	{
		return;
	}

	
//---------------------获取滤网信息-----------------------------
	Addr = FLASH_FILTER_400;
	do
	{

		memset(&tTmp[0],0,sizeof(tTmp)); //缓存数据数组清除
		for(i=0; i<7; i++) //获取数据参数8个参数 两个针头 一个数据长度 两个CRC
	    {
	        tTmp[i] = *((uint8_t *)(Addr+i));
	    }
		Addr+=512;
		if(tTmp[0]==0xfe &&tTmp[1]==0xff)
		{
			datalen = tTmp[2];
			datatmp=fCRC16_cal(&tTmp[3], datalen);
			if(datatmp == ((tTmp[datalen+3]<<8)|tTmp[datalen+4]))
			{
				memcpy(&Filter.Normalaccumulated_10min,&tTmp[3],datalen);
				break;
			}
		}
	}
	while (Addr<=FLASH_FILTER_600);

	
//---------------------获取系统状态信息-----------------------------
	Addr = FLASH_SYSSTATUS_800;
	do
	{
		memset(&tTmp[0],0,sizeof(tTmp)); //缓存数据数组清除
		for(i=0; i<20; i++) //获取数据参数 N个参数 两个针头 一个数据长度 两个CRC
	    {
	        tTmp[i] = *((uint8_t *)(Addr+i));
	    }
		Addr+=512;
		if(tTmp[0]==0xfe &&tTmp[1]==0xff)
		{
			datalen = tTmp[2];
			datatmp=fCRC16_cal(&tTmp[3], datalen);
			i=3;
			if(datatmp == ((tTmp[datalen+3]<<8)|tTmp[datalen+4]))
			{
				Sys.wifisetcnt=tTmp[i++];; // wifi配置次数
				Sys.Wifi_EWS_DONE_flg= tTmp[i++];
				if(Sys.Wifi_EWS_DONE_flg)  //假如wifi标志原先配置过
				{
					DI.Port2_wifiu.para2.connection = wifi_C_requested;  //1 notconnectd 2requested 3connecting 4connected 5error
					DI.Port2_wifiu.para3.setup = wifi_S_inactive; // 1inactive 2requested 3active
				}
				else
				{
					DI.Port2_wifiu.para2.connection = wifi_C_not_connected; //进入配网状态
					DI.Port2_wifiu.para3.setup = wifi_S_requested;
				}
				if(Sys.Wifi_EWS_DONE_flg)
					Sys.wifisetcnt = 0;
					
				DI.Port3_air.para2.power = tTmp[i++];
				if(DI.Port3_air.para2.power) //只有开机才会执行之前记忆数据 未开机恢复到默认状态
				{
					DI.Port3_air.para17.aqit = tTmp[i++];
					Sys.IAQL_memvalue = DI.Port3_air.para9.iaql = tTmp[i++];
					Sys.PM25_memvalue = tTmp[i++];
					Sys.PM25_memvalue<<=8;
					Sys.PM25_memvalue +=tTmp[i++];
					DI.Port3_air.para10.pm25=Sys.PM25_memvalue;
					DI.Port3_air.para3.childLock = tTmp[i++];
					DI.Port3_air.para4.AQILight = tTmp[i++];
					DI.Port3_air.para5.UIlight = tTmp[i++];
					DI.Port3_air.para6.userautomodesetting = tTmp[i++];
					DI.Port3_air.para7.opmode = tTmp[i++];
					DI.Port3_air.para16.rddp=DI.Port3_air.para15.ddp = tTmp[i++];
					
				}
				break;
			}
		}
	}
	while (Addr<=FLASH_SYSSTATUS_A00);


//---------------------获取设备信息-----------------------------
//---------------------获取设备name 还有wifi协议版本--------------
	Addr = FLASH_PORT1DEVICE_C00;
	do
	{

		memset(&tTmp[0],0,sizeof(tTmp)); //缓存数据数组清除
		for(i=0; i<50; i++) //获取数据参数N个 两个桢头 一个数据长度 两个CRC 数据长度=信息数据长度+5
		{
			tTmp[i] = *((uint8_t *)(Addr+i));
		}
		Addr+=512;
		if(tTmp[0]==0xfe &&tTmp[1]==0xff) // 桢头准确
		{
			datalen = tTmp[2]; //获取信息数据长度
			datatmp=fCRC16_cal(&tTmp[3], datalen); //获取信息数据的CRC校验和
			i=3;
			if(datatmp == ((tTmp[datalen+3]<<8)|tTmp[datalen+4])) //CRC校验正确之后解析数据
			{	
				memcpy(&DI.Port1_device.para3.Props,&tTmp[i],tTmp[i+1]+2); //name 不定长度
				i+=tTmp[i+1]+2;
				//memcpy(&DI.Port1_device.para10.Props,&tTmp[i],tTmp[i+1]+2); //wifi协议版本
				break;
			}
		}
	}
	while (Addr<=FLASH_PORT1DEVICE_E00);
		
	if(Sys.Wifi_EWS_DONE_flg)
	{
		DI.Port2_wifiu.para2.connection = wifi_C_requested;  //1 notconnectd 2requested 3connecting 4connected 5error
		DI.Port2_wifiu.para3.setup = wifi_S_inactive; // 1inactive 2requested 3active
	}
	else
	{
		DI.Port2_wifiu.para2.connection = wifi_C_not_connected; //进入配网状态
		DI.Port2_wifiu.para3.setup = wifi_S_requested;
	}

	if(DI.Port3_air.para2.power == 1)  //掉电记忆下面 如果之前是开机的状态 那么直接取消预热
	{
		Sys.Warmup30s_Cnt=301; //直接跳过预热 ---30S动画
		Sys.Plugin_Cnt=31; //直接跳过3秒上电画面
		Sys.AQI_LEVEL = 0;  //默认为初始化为0
		if(DI.Port3_air.para15.ddp == eddpIAI) //IAI显示
		{
			while(DI.Port3_air.para9.iaql >= tIAI[Sys.AQI_LEVEL][1])  //判断当前的IAI等级
			{
				Sys.AQI_LEVEL++;
				if(Sys.AQI_LEVEL>3)  //最多就处于第4档位  0-3
				{
					Sys.AQI_LEVEL = 3;
					break;
				}
					
			}
		}
		else
		{
			while(DI.Port3_air.para10.pm25 >= tPM25[market][Sys.AQI_LEVEL][1]) //判断当前的PM2.5等级
			{
				Sys.AQI_LEVEL++;
				if(Sys.AQI_LEVEL>3)  //最多就处于第4档位  0-3
				{
					Sys.AQI_LEVEL = 3;
					break;
				}
					
			}
		}
	}
	else
	{
		Buz_Once();  //只有之前是关机的状态才会上电蜂鸣
	}
}







void fInitial_Portprocess()  // 初始化处理
{
	memset(&tTxBuffer[0],0,sizeof(tTxBuffer));
	if(DI.Status == 0) //前面都正常
	{
		if(DI.rxPayloadLenth!=2)  //假如数据个数不为2
		{
			DI.Status = 0x0c; //非法数据
		}
		else
		{
			DI.Status = 0; //合法数据
		}
	}
		
	DI.txPayloadLenth = 0X0003;
	tTxBuffer[0] = 0xfe;
	tTxBuffer[1] = 0xff;
	
	tTxBuffer[2] = 0x02; //respons
	tTxBuffer[3] = DI.txPayloadLenth>>8;
	tTxBuffer[4] = DI.txPayloadLenth&0xff;
	tTxBuffer[5] = DI.Status;
	tTxBuffer[6] = DI.WiFiProtocolVersion;
	tTxBuffer[7] = DI.clientHints;
	DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.txPayloadLenth);
	tTxBuffer[8]=DI.CRC>>8;
	tTxBuffer[9] =DI.CRC&0xff;
	R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], 10);
}
void fGet_Portprocess(ePortdef port)  // wifi数据处理
{
	u8 i=0;
	u8 *Payloadpoint = 0;  //指向MCU存放的数据地址
	u8 *PayloadSendpoint=0; //指向将要发送的数据地址 tTxBuffer
	u16 Payloadlenth = 0;
	u32 datatmp32;
	u16 datatmp16;
	memset(&tTxBuffer[0],0,sizeof(tTxBuffer));
	tTxBuffer[0]= 0xfe;
	tTxBuffer[1]= 0xff;
	tTxBuffer[2]= 0x07;  // Response ID
	
	if(port==0||port>8)
	{
		DI.Status = 0x03;
	}
	if(DI.Status)
	{
		DI.txPayloadLenth = 3;
		tTxBuffer[3]= DI.txPayloadLenth>>8;
		tTxBuffer[4]= DI.txPayloadLenth&0xff;
		tTxBuffer[5] = DI.Status;
		tTxBuffer[6] = port ;
		tTxBuffer[7] = 0x00;
		DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.txPayloadLenth);
		tTxBuffer[8]=DI.CRC>>8;
		tTxBuffer[9] =DI.CRC&0xff;
		R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], 10);
		return;
	}
	PayloadSendpoint = &tTxBuffer[7];
	switch (port)
	{
		case Port_device:
			
			Payloadpoint=&DI.Port1_device.para1.Props; //指向第一个个参数
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port1_device.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port1_device.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

//			Payloadpoint=&DI.Port1_device.para6.Props;
//			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
//			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para8.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para9.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.paraA.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.paraB.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port1_device.para10.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para11.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para12.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port1_device.para13.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para14.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port1_device.para14.node0bootloaderchecksum;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port1_device.para15.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port1_device.para15.node0Applicationchecksum;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			break;
		case Port_wifiui:
			Payloadpoint=&DI.Port2_wifiu.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port2_wifiu.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port2_wifiu.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port2_wifiu.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			break;
		case Port_air:
			Payloadpoint=&DI.Port3_air.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port3_air.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16); // 因为串口发送是高位在前 但是存储的格式是小端格式 低位地址存储的是低位字节的数据 所以得转换一下数据格式
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port3_air.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para6.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para8.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para9.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para10.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port3_air.para10.pm25;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

//			Payloadpoint=&DI.Port3_air.para11.Props;
//			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
//			PayloadSendpoint+= (2+*(Payloadpoint+1));

//			Payloadpoint=&DI.Port3_air.para12.Props;
//			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
//			PayloadSendpoint+= (2+*(Payloadpoint+1));

			
//			Payloadpoint=&DI.Port3_air.para13.Props;
//			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
//			PayloadSendpoint+= (2+*(Payloadpoint+1));

//			Payloadpoint=&DI.Port3_air.para14.Props;
//			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
//			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para15.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para16.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para17.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port3_air.para18.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port3_air.para18.errorcode;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			break;
			
		case Port_fac:
			Payloadpoint=&DI.Port4_fac.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port4_fac.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port4_fac.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port4_fac.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port4_fac.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			break;
		case Port_fltsts:
			Payloadpoint=&DI.Port5_fltsts.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port5_fltsts.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para4.filter0lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para5.filter1lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para6.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para6.filter2lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para7.filter0remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para8.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para8.filter1remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port5_fltsts.para9.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port5_fltsts.para9.filter2remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			
			break;
		case Port_flttest:
			Payloadpoint=&DI.Port6_flttest.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port6_flttest.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para4.filter0lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para5.filter1lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para6.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para6.filter2lifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para7.filter0remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para8.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para8.filter1remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para9.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para9.filter2remaininglifetime;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para10.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp32 = DI.Port6_flttest.para10.filter1CCMcurrent;
			datatmp32 = BigtoLittle32(datatmp32);
			memcpy(PayloadSendpoint+2,&datatmp32,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port6_flttest.para11.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp32 = DI.Port6_flttest.para11.filter1lifecurrent;
			datatmp32 = BigtoLittle32(datatmp32);
			memcpy(PayloadSendpoint+2,&datatmp32,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para12.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para12.K1CountValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para13.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para13.K1ReferenceValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para14.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para14.K2CountValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para15.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para15.K2ReferenceValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para16.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para16.K3CountValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));


			Payloadpoint=&DI.Port6_flttest.para17.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port6_flttest.para17.K3ReferenceValue;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			break;

			
		case Port_network:
			Payloadpoint=&DI.Port7_network.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port7_network.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			
			Payloadpoint=&DI.Port7_network.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para6.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port7_network.para8.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			break;
		case Port_otau:
			Payloadpoint=&DI.Port8_otau.para1.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port8_otau.para1.portpollinginterval;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));
			
			Payloadpoint=&DI.Port8_otau.para2.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port8_otau.para3.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port8_otau.para4.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port8_otau.para4.currentpackagenumber;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port8_otau.para5.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp16 = DI.Port8_otau.para5.totalpackagenumber;
			datatmp16 = BigtoLittle16(datatmp16);
			memcpy(PayloadSendpoint+2,&datatmp16,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port8_otau.para6.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2+*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			Payloadpoint=&DI.Port8_otau.para7.Props;
			memcpy(PayloadSendpoint,Payloadpoint,2); //目标地址为TXbuff,源地址为指向的参数地址，需要赋值的个数为属性一个+长度一个+长度的数据
			datatmp32 = DI.Port8_otau.para7.checksum;
			datatmp32 = BigtoLittle32(datatmp32);
			memcpy(PayloadSendpoint+2,&datatmp32,*(Payloadpoint+1));
			PayloadSendpoint+= (2+*(Payloadpoint+1));

			break;
		

	}
	
	tTxBuffer[5] = DI.Status;
	tTxBuffer[6] = port;
	DI.rxPayloadLenth = ((u16)(PayloadSendpoint-&tTxBuffer[4]));
	tTxBuffer[3]= DI.rxPayloadLenth>>8;
	tTxBuffer[4]= DI.rxPayloadLenth&0xff;
	*PayloadSendpoint++=0; // 最后一个Props 值位0
	DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.rxPayloadLenth);
	*PayloadSendpoint++=DI.CRC>>8;
	*PayloadSendpoint++=DI.CRC&0xff;
	R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], DI.rxPayloadLenth+7);
}

void fPut_Portprocess(ePortdef port)  // wifi数据处理
{
	u8 *recPayloadpoint = &tRxBuffer[6]; //指向接收数据的props
	u8 *Payloadpoint = &DI.Port1_device.para1.portpollinginterval;  //申请一个指针 准备指向需要存放的缓存DI 先默认指向第一个元素的数据 避免出错
	u8 txTotalCnt = 7; //  总共发送数据的计数 从第7位开始推算 Props
	u8 Buzpowerflg = 0;
	u8 LightSetFlg = 0;
	memset(&tTxBuffer[0],0,sizeof(tTxBuffer));
	tTxBuffer[0] = 0xfe;
	tTxBuffer[1] = 0xff;
	tTxBuffer[2] = 0x07; //respons
	
	
	tTxBuffer[6] = port;
	if(DI.Status==0) // 状态正常
	{
		switch (port)
		{
			case Port_device:
				do
				{	
					DI.reqProps = *recPayloadpoint++; //获取Props
					DI.reqPropslen = *recPayloadpoint++;//取得该属性的数据长度 ++之后recPayloadpoint指向了参数内容
					switch (DI.reqProps)
					{
						case 0x01: // 参数1	portpollinginterval 字节数2 范围0-ffff	
							Payloadpoint = &DI.Port1_device.para1.portpollinginterval; //指向缓存的数据地址
							if(DI.reqPropslen!=*(Payloadpoint-1)) //数据地址之前是长度的地址 接收的长度和缓存的长度需要一致
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址							
							break;
						case 0x03:  //注意名字字节不能超过30
							Payloadpoint = &DI.Port1_device.para3.name[0];
							if(DI.reqPropslen>30) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址				
							break;

						case 0x10:
							Payloadpoint = &DI.Port1_device.para10.wifimodulefwversion[0];
							if(DI.reqPropslen>6) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址		
							break;

						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
						
					}
				}
				while ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_wifiui:
				do
				{
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01: // 参数1	portpollinginterval 字节数2 范围0-ffff					
							Payloadpoint = &DI.Port2_wifiu.para1.portpollinginterval;
							
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}						
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02: //连接状态 1-5
							Payloadpoint = &DI.Port2_wifiu.para2.connection;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) || *recPayloadpoint==0||*recPayloadpoint>5) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03://设置状态 1-3
							Payloadpoint = &DI.Port2_wifiu.para3.setup;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) || *recPayloadpoint==0||*recPayloadpoint>3) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
						break;
						
					}
				}
				while ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_air:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01: // 参数1  
							Payloadpoint = &DI.Port3_air.para1.portpollinginterval;
							
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02:  //开关变量 0-1
							Payloadpoint = &DI.Port3_air.para2.power;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03: //童锁0-1
							Payloadpoint = &DI.Port3_air.para3.childLock;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}				
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x04://aqil aqi灯亮度 0  50  100
							Payloadpoint = &DI.Port3_air.para4.AQILight;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||(*recPayloadpoint!=50&&*recPayloadpoint!=0&&*recPayloadpoint!=100)) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}						
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x05://UI灯亮度 0   50  100
							Payloadpoint = &DI.Port3_air.para5.UIlight;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||(*recPayloadpoint!=50&&*recPayloadpoint!=0&&*recPayloadpoint!=100)) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x0b: // user autp mode setting 0-1
							Payloadpoint = &DI.Port3_air.para6.userautomodesetting;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x0c:// opMode 0-1-2-4-5
							Payloadpoint = &DI.Port3_air.para7.opmode;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>=3) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x0d: //fan speed 0-4
							Payloadpoint = &DI.Port3_air.para8.fanspeed;
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>4) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x2a: //DDP 0-1
							Payloadpoint = &DI.Port3_air.para15.ddp;
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}						
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x2c://AQIT 1-12
							Payloadpoint = &DI.Port3_air.para17.aqit;
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>12||*recPayloadpoint==0) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}											
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
						
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0 &&DI.reqProps!=0); //&& *recPayloadpoint!=0
				break;
			case Port_fac:
				do
				{
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01://轮询时间 2个字节
							Payloadpoint = &DI.Port4_fac.para1.portpollinginterval;
							
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}					
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02: //PCBA 0-1
							Payloadpoint = &DI.Port4_fac.para2.pcba;
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}					
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03: //WIFI 0-1
							Payloadpoint = &DI.Port4_fac.para3.wifi;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}						
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x04://RESET 0-1
							Payloadpoint = &DI.Port4_fac.para4.reset;
						
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>1) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;	
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_fltsts:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port5_fltsts.para1.portpollinginterval;
						
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;	
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_flttest:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port6_flttest.para1.portpollinginterval;
						
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02:// filtype1 1-9
							Payloadpoint = &DI.Port6_flttest.para2.filtertype1;
						
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint==0||*recPayloadpoint>9) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03:// filtype2 0-9
							Payloadpoint = &DI.Port6_flttest.para3.filtertype2;
							
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>9) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x07: // filter0 lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para4.filter0lifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;	
						case 0x08:// filter1 lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para5.filter1lifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;					
						case 0x09:// filter2 lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para6.filter2lifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x0d:// filter0 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para7.filter0remaininglifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;	
						case 0x0e:// filter1 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para8.filter1remaininglifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;					
						case 0x0f:// filter2 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para9.filter2remaininglifetime;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是2就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x13://filetr1 CCM current time 4字节
							Payloadpoint = &DI.Port6_flttest.para10.filter1CCMcurrent;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是5就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;					
						case 0x14: //filetr1 life current time 4字节
							Payloadpoint = &DI.Port6_flttest.para11.filter1lifecurrent;
							if(DI.reqPropslen!=*(Payloadpoint-1) ) //只需要判断接收的字节数是否是5就可以了
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_network:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port7_network.para1.portpollinginterval;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02:
							Payloadpoint = &DI.Port7_network.para2.macaddress[0];
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03:
							Payloadpoint = &DI.Port7_network.para3.ipaddress[0];
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}														
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x04:
							Payloadpoint = &DI.Port7_network.para4.subnetmask[0];
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x05:
							Payloadpoint = &DI.Port7_network.para5.wifissid[0];
							if(DI.reqPropslen>32) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x06:
							Payloadpoint = &DI.Port7_network.para6.wifipasscode[0];
							if(DI.reqPropslen>63) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}													
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x07:
							Payloadpoint = &DI.Port7_network.para7.defaultgateway;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x08:
							Payloadpoint = &DI.Port7_network.para8.dhcpserver;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
					
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;
			case Port_otau:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port8_otau.para1.portpollinginterval;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x02:
							Payloadpoint = &DI.Port8_otau.para2.state;
							if(DI.reqPropslen!=*(Payloadpoint-1) ||*recPayloadpoint>3) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}								
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x03:
							Payloadpoint = &DI.Port8_otau.para3.devicefirmwareversion[0];
							if(DI.reqPropslen>10) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x04:
							Payloadpoint = &DI.Port8_otau.para4.currentpackagenumber;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}	
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x05:
							Payloadpoint = &DI.Port8_otau.para5.totalpackagenumber;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}					
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x06:
							Payloadpoint = &DI.Port8_otau.para6.data[0];
							if(DI.reqPropslen>128) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;
						case 0x07:
							Payloadpoint = &DI.Port8_otau.para7.checksum;
							if(DI.reqPropslen!=*(Payloadpoint-1)) //只需要判断接收的字节数是否正确
							{
								DI.Status = 0x0c; // invalid parameter
							}							
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							break;	
						default:
							DI.reqPropslen = 0;
							recPayloadpoint--;
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth && DI.Status==0); //&& *recPayloadpoint!=0
				break;

			default:
				DI.Status=0x03; // no such port
				break;
		}	
	}

	if(DI.Status==0)
	{
		if((recPayloadpoint-&tRxBuffer[4])>DI.rxPayloadLenth) //
			DI.Status=0x06; // props not implemented
	}
	recPayloadpoint = &tRxBuffer[6]; //重新指向接收数据的props
	if(DI.Status!=0)
	{
		DI.txPayloadLenth = 3;
		tTxBuffer[0] = 0xfe;
		tTxBuffer[1] = 0xff;
		tTxBuffer[2] = 0x07; //respons
		tTxBuffer[3] = 0x00;
		tTxBuffer[4] = 0x03;
		tTxBuffer[5] = DI.Status;
		tTxBuffer[6] = port;
		tTxBuffer[7] = 0x00;
		DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.txPayloadLenth);
		tTxBuffer[8]=DI.CRC>>8;
		tTxBuffer[9] =DI.CRC&0xff;
		R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], 10);
	}
	else
	{
		switch (port)
		{
			case Port_device:
				do
				{	
					DI.reqProps = *recPayloadpoint++; //获取Props
					DI.reqPropslen = *recPayloadpoint++;//取得该属性的数据长度 ++之后recPayloadpoint指向了参数内容
					switch (DI.reqProps)
					{
						case 0x01: // 参数1	portpollinginterval 字节数2 范围0-ffff	
							Payloadpoint = &DI.Port1_device.para1.portpollinginterval; //指向缓存的数据地址
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port1_device.para1.portpollinginterval = BigtoLittle16(DI.Port1_device.para1.portpollinginterval);
							break;
						case 0x03:  //注意名字字节不能超过30
							Payloadpoint = &DI.Port1_device.para3.name[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址	
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;

						case 0x10:
							Payloadpoint = &DI.Port1_device.para10.wifimodulefwversion[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址		
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;

						default:
							DI.Status=0x06; // props not implemented
							break;
						
					}
					
				}
				while ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				
				break;
			case Port_wifiui:
				do
				{
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01: // 参数1	portpollinginterval 字节数2 范围0-ffff					
							Payloadpoint = &DI.Port2_wifiu.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port2_wifiu.para1.portpollinginterval = BigtoLittle16(DI.Port2_wifiu.para1.portpollinginterval);
							break;
						case 0x02: //连接状态 1-5
							Payloadpoint = &DI.Port2_wifiu.para2.connection;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x03://设置状态 1-3
							Payloadpoint = &DI.Port2_wifiu.para3.setup;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						default:
							DI.Status=0x06; // props not implemented
						break;
						
					}
				}
				while ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				break;
			case Port_air:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01: // 参数1  
							Payloadpoint = &DI.Port3_air.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port3_air.para1.portpollinginterval = BigtoLittle16(DI.Port3_air.para1.portpollinginterval);
							break;
						case 0x02:  //开关变量 0-1
							Payloadpoint = &DI.Port3_air.para2.power;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
								if(DI.Port3_air.para2.power)
									fPower_On();
								else
									fPower_Off();
								
								Buzpowerflg = 1;
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x03: //童锁0-1
							Payloadpoint = &DI.Port3_air.para3.childLock;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x04://aqil aqi灯亮度 0  50  100
							Payloadpoint = &DI.Port3_air.para4.AQILight;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
								
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							if(DI.Port3_air.para4.AQILight !=DI.Port3_air.para5.UIlight)  //两者保持一致
							{
								DI.Port3_air.para5.UIlight = DI.Port3_air.para4.AQILight;
							}

							if(DI.Port3_air.para4.AQILight!=eLightoff)
							{
								Sys.Sleep3S_Cnt = 3; // 需要开启
							}
							if(DI.Port3_air.para5.UIlight!=eLightNomal)
								Sys.eLight20S_Cnt = 21; //21赋值表示该模式下不允许光传感器改变状态 21的计数不会递减
							else
								Sys.eLight20S_Cnt = 20; //正常模式下运行光传感器工作
							LightSetFlg = 1;
							break;
						case 0x05://UI灯亮度 0   50  100
							Payloadpoint = &DI.Port3_air.para5.UIlight;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							if(DI.Port3_air.para4.AQILight !=DI.Port3_air.para5.UIlight) //两者保持一致
							{
								DI.Port3_air.para4.AQILight=DI.Port3_air.para5.UIlight;
							}
							if(DI.Port3_air.para4.AQILight!=eLightoff)
							{
								Sys.Sleep3S_Cnt = 3; // 需要开启
							}
							if(DI.Port3_air.para5.UIlight!=eLightNomal)
								Sys.eLight20S_Cnt = 21;  //21赋值表示该模式下不允许光传感器改变状态 21的计数不会递减
							else
								Sys.eLight20S_Cnt = 20;	//正常模式下运行光传感器工作
							LightSetFlg = 1;
							break;
						case 0x0b: // user autp mode setting 0-1
							Payloadpoint = &DI.Port3_air.para6.userautomodesetting;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							
							break;
						case 0x0c:// opMode 0-1-2-4-5
							Payloadpoint = &DI.Port3_air.para7.opmode;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							
							break;
						case 0x0d: //fan speed 0-4
							Payloadpoint = &DI.Port3_air.para8.fanspeed;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
														
							break;
						case 0x2a: //DDP 0-1
							Payloadpoint = &DI.Port3_air.para15.ddp;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							
							break;
						case 0x2c://AQIT 1-12
							Payloadpoint = &DI.Port3_air.para17.aqit;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							
							break;
						default:
							DI.Status=0x06; // props not implemented
							break;
						
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				if(DI.Status == 0)
				{
					if(Buzpowerflg == 0) //没有开关机操作
						Buz_Once();
					if(LightSetFlg == 0)  //没有设置灯光
					{
						if(DI.Port3_air.para4.AQILight!=eLightNomal) //只要是非正常显示
						{
							DI.Port3_air.para4.AQILight = DI.Port3_air.para5.UIlight = eLightNomal;
						}
						Sys.eLight20S_Cnt = 20;	//正常模式下运行光传感器工作 时间需要刷新
						Sys.Sleep3S_Cnt = 3; // 需要开启
					}
						
				}
				LightSetFlg = 0;
				Buzpowerflg = 0;
				break;
			case Port_fac:
				do
				{
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01://轮询时间 2个字节
							Payloadpoint = &DI.Port4_fac.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port4_fac.para1.portpollinginterval = BigtoLittle16(DI.Port4_fac.para1.portpollinginterval);
							break;
						case 0x02: //PCBA 0-1
							Payloadpoint = &DI.Port4_fac.para2.pcba;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x03: //WIFI 0-1
							Payloadpoint = &DI.Port4_fac.para3.wifi;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x04://RESET 0-1
							Payloadpoint = &DI.Port4_fac.para4.reset;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;	
						default:
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				break;
			case Port_fltsts:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port5_fltsts.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port5_fltsts.para1.portpollinginterval = BigtoLittle16(DI.Port5_fltsts.para1.portpollinginterval);
							break;	
						default:
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				break;
			case Port_flttest:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port6_flttest.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para1.portpollinginterval = BigtoLittle16(DI.Port6_flttest.para1.portpollinginterval);
							break;
						case 0x02:// filtype1 1-9
							Payloadpoint = &DI.Port6_flttest.para2.filtertype1;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port5_fltsts.para2.filtertype1 = DI.Port6_flttest.para2.filtertype1;
							break;
						case 0x03:// filtype2 0-9
							Payloadpoint = &DI.Port6_flttest.para3.filtertype2;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port5_fltsts.para3.filtertype2 = DI.Port6_flttest.para3.filtertype2;
							break;
						case 0x07: // filter0 lifetime 2字节  预置滤网时间
							Payloadpoint = &DI.Port6_flttest.para4.filter0lifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para4.filter0lifetime = BigtoLittle16(DI.Port6_flttest.para4.filter0lifetime);
							DI.Port5_fltsts.para4.filter0lifetime = DI.Port6_flttest.para4.filter0lifetime;
							Filter.PreLifemaxhour = DI.Port5_fltsts.para4.filter0lifetime; //预置滤网时间
							break;	
						case 0x08:// filter1 lifetime 2字节  普通滤网最大时间
							Payloadpoint = &DI.Port6_flttest.para5.filter1lifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para5.filter1lifetime = BigtoLittle16(DI.Port6_flttest.para5.filter1lifetime);
							DI.Port5_fltsts.para5.filter1lifetime = DI.Port6_flttest.para5.filter1lifetime;
							Filter.NormalLifemaxhour = DI.Port5_fltsts.para5.filter1lifetime; //设置滤网最大运行时间
							break;					
						case 0x09:// filter2 lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para6.filter2lifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para6.filter2lifetime = BigtoLittle16(DI.Port6_flttest.para6.filter2lifetime);
							DI.Port5_fltsts.para6.filter2lifetime = DI.Port6_flttest.para6.filter2lifetime;
							break;
						case 0x0d:// filter0 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para7.filter0remaininglifetime;
							//propPointTable[i++]=&DI.Port6_flttest.para7.filter0remaininglifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para7.filter0remaininglifetime = BigtoLittle16(DI.Port6_flttest.para7.filter0remaininglifetime);
							DI.Port5_fltsts.para7.filter0remaininglifetime = DI.Port6_flttest.para7.filter0remaininglifetime;
							if(DI.Port5_fltsts.para4.filter0lifetime>=DI.Port5_fltsts.para7.filter0remaininglifetime)
							{
								Filter.Preaccumulated_hour = DI.Port5_fltsts.para4.filter0lifetime-DI.Port5_fltsts.para7.filter0remaininglifetime;
							}
							break;	
						case 0x0e:// filter1 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para8.filter1remaininglifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para8.filter1remaininglifetime = BigtoLittle16(DI.Port6_flttest.para8.filter1remaininglifetime);
							DI.Port5_fltsts.para8.filter1remaininglifetime = DI.Port6_flttest.para8.filter1remaininglifetime;
							if(DI.Port5_fltsts.para5.filter1lifetime>=DI.Port5_fltsts.para8.filter1remaininglifetime)
							{
								Filter.Normalaccumulated_hour = DI.Port5_fltsts.para5.filter1lifetime-DI.Port5_fltsts.para8.filter1remaininglifetime;
								Filter.Normalaccumulated_10min = Filter.Normalaccumulated_hour*6;
							}

							
							break;					
						case 0x0f:// filter2 remaining lifetime 2字节
							Payloadpoint = &DI.Port6_flttest.para9.filter2remaininglifetime;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para9.filter2remaininglifetime = BigtoLittle16(DI.Port6_flttest.para9.filter2remaininglifetime);
							DI.Port5_fltsts.para9.filter2remaininglifetime = DI.Port6_flttest.para9.filter2remaininglifetime;
							break;
						case 0x13://filetr1 CCM current time 4字节
							Payloadpoint = &DI.Port6_flttest.para10.filter1CCMcurrent;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para10.filter1CCMcurrent=BigtoLittle32(DI.Port6_flttest.para10.filter1CCMcurrent);
							Filter.CCMaccumulated_ug = DI.Port6_flttest.para10.filter1CCMcurrent*1000; //传输值是mg
							break;					
						case 0x14: //filetr1 life current time 4字节
							Payloadpoint = &DI.Port6_flttest.para11.filter1lifecurrent;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port6_flttest.para11.filter1lifecurrent=BigtoLittle32(DI.Port6_flttest.para11.filter1lifecurrent);
							Filter.Normalaccumulated_hour = DI.Port6_flttest.para11.filter1lifecurrent;
							Filter.Normalaccumulated_10min = Filter.Normalaccumulated_hour*6;
							
							break;
						default:
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				if(DI.Status == 0)  //状态正常情况下 需要保存
				{
					fFilter_PercentageCal();
					Filter.Storeflg = 1; //需要延后一秒经过计算再保存	
				}
				break;
			case Port_network:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port7_network.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port7_network.para1.portpollinginterval = BigtoLittle16(DI.Port7_network.para1.portpollinginterval);
							break;
						case 0x02:
							Payloadpoint = &DI.Port7_network.para2.macaddress[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x03:
							Payloadpoint = &DI.Port7_network.para3.ipaddress[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x04:
							Payloadpoint = &DI.Port7_network.para4.subnetmask[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x05:
							Payloadpoint = &DI.Port7_network.para5.wifissid[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x06:
							Payloadpoint = &DI.Port7_network.para6.wifipasscode[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x07:
							Payloadpoint = &DI.Port7_network.para7.defaultgateway;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x08:
							Payloadpoint = &DI.Port7_network.para8.dhcpserver;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						default:
							DI.Status=0x06; // props not implemented
							break;
					
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				break;
			case Port_otau:
				do
				{	
					DI.reqProps = *recPayloadpoint++;
					DI.reqPropslen = *recPayloadpoint++;
					switch (DI.reqProps)
					{
						case 0x01:
							Payloadpoint = &DI.Port8_otau.para1.portpollinginterval;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port8_otau.para1.portpollinginterval = BigtoLittle16(DI.Port8_otau.para1.portpollinginterval);
							break;
						case 0x02:
							Payloadpoint = &DI.Port8_otau.para2.state;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x03:
							Payloadpoint = &DI.Port8_otau.para3.devicefirmwareversion[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x04:
							Payloadpoint = &DI.Port8_otau.para4.currentpackagenumber;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port8_otau.para4.currentpackagenumber = BigtoLittle16(DI.Port8_otau.para4.currentpackagenumber);
							break;
						case 0x05:
							Payloadpoint = &DI.Port8_otau.para5.totalpackagenumber;
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port8_otau.para5.totalpackagenumber = BigtoLittle16(DI.Port8_otau.para5.totalpackagenumber);
							break;
						case 0x06:
							Payloadpoint = &DI.Port8_otau.para6.data[0];
							if(DI.Status==0) // 帧数据正常 正常赋值 并且做出应答
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							break;
						case 0x07:
							Payloadpoint = &DI.Port8_otau.para7.checksum;
							if(DI.Status==0)
							{
								memset(Payloadpoint,0,*(Payloadpoint-1));
								memcpy(Payloadpoint-2,recPayloadpoint-2,DI.reqPropslen+2); //将缓存的值复制到结构体中 数据有效 从Prpos开始 到数据结束 从Prpos开始 到数据结束
							}
							recPayloadpoint+=DI.reqPropslen; // 指针指向下个props首地址
							memcpy(&tTxBuffer[txTotalCnt],(Payloadpoint-2),DI.reqPropslen+2);
							txTotalCnt+=(DI.reqPropslen+2); // 下一个属性开始的位置	
							DI.Port8_otau.para7.checksum = BigtoLittle32(DI.Port8_otau.para7.checksum);
							break;
						
						default:
							DI.Status=0x06; // props not implemented
							break;
					}
				}
				while  ((recPayloadpoint-&tRxBuffer[4])<DI.rxPayloadLenth ); //&& *recPayloadpoint!=0
				break;

		}
		if(DI.Port8_otau.para2.state==3) //wifi模块让我重启设备
		{
			while(1);  // 使得看门狗超时
		}
		if(Sys.Factoryflg)
		{
			if(Sys.Factorywifisteps == 1 && DI.Port4_fac.para2.pcba==0) // 产测wifi PCBA结束
			{
				Sys.Factorywifisteps = 2; //产测wifi wifi开始
				DI.Port4_fac.para2.pcba = 0;
				DI.Port4_fac.para3.wifi = 1;  //开始测试wifi模块
				DI.Port4_fac.para4.reset = 0;  //
			}

				
			if(Sys.Factorywifisteps == 2 && DI.Port4_fac.para3.wifi==0) //wifi自检成功会自动清除wifi标志 所以判断wifi成功就进入最后一部检测 reset
			{
				Sys.Factorywifisteps = 3; //产测wifi  reset 开始
				DI.Port4_fac.para2.pcba = 0;
				DI.Port4_fac.para3.wifi = 0;
				DI.Port4_fac.para4.reset =1; 
			}

			if(Sys.Factorywifisteps == 3 && DI.Port4_fac.para4.reset==0) // 产测wifi reset结束
			{
				Sys.Factorywifisteps = 4; //针对wifi模块的产测功能完成
			}
		}
		fGet_Portprocess(port); //PUt 数据所有的一整帧数据回复
		/*
		if(port == Port_fac) //获取产测状态 全回  其他回复put的指令
		{
			fGet_Portprocess(port); //PUt 数据所有的一整帧数据回复
		}
		else
		{
			tTxBuffer[txTotalCnt++] = 0x00; //结束位置 txTotalCnt的位置是最后一个props 应该为停止位0
			DI.txPayloadLenth = txTotalCnt-5;
			tTxBuffer[3] = DI.txPayloadLenth>>8;
			tTxBuffer[4] = DI.txPayloadLenth&0xff;
			DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.txPayloadLenth);
			tTxBuffer[5] = DI.Status;
			tTxBuffer[txTotalCnt++] =DI.CRC>>8;
			tTxBuffer[txTotalCnt++] =DI.CRC&0xff;
			R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], txTotalCnt);
		}
		*/
	}
	
	
}




void fWifi_Dataprocess(void)  // wifi数据处理
{	
	DI.reqopID = (eIDtypedef)tRxBuffer[2];
	DI.rxPayloadLenth = (tRxBuffer[3]<<8)+tRxBuffer[4];
	DI.Port3_air.para4.AQILight = DI.Port3_air.para5.UIlight;
	DI.Port3_air.para16.rddp = DI.Port3_air.para15.ddp;
	DI.Port3_air.para18.errorcode = 0;
	if(Sys.Errcode&bit0) // 
	{
		DI.Port3_air.para18.errorcode = 0x8001;
	}
	else if(Sys.Errcode&bit1) // particle sensoer error
	{
		DI.Port3_air.para18.errorcode = 0x8002;
	}
	else  //warning 警告
	{
		if(Sys.Errcode&bit2)  //pre cleaning warning  F0
		{
			DI.Port3_air.para18.errorcode|=0xc001;
		}

		if(Sys.Errcode&bit3) // Filter replace warning F1
		{
			DI.Port3_air.para18.errorcode|=0xc002;
		}

		if(Sys.Errcode&bit4) // Filter replace alert lock F2
		{
			DI.Port3_air.para18.errorcode|=0xc004;
		}
	}
//	if(Motorpara.Spd_Output[0]==Motorpara.Spd_Off[0])
//		DI.Port3_air.para8.fanspeed = espdOff;
//	else if(Motorpara.Spd_Output[0]==Motorpara.Spd_Sleep[0]) //
//		DI.Port3_air.para8.fanspeed = espdSleep;
//	else if(Motorpara.Spd_Output[0]==Motorpara.Spd_Turbo[0]) //
//		DI.Port3_air.para8.fanspeed = espdTurbo;
//	else if(Motorpara.Spd_Output[0]==Motorpara.Spd1[0]) //
//		DI.Port3_air.para8.fanspeed = espd1;
//	else if(Motorpara.Spd_Output[0]==Motorpara.Spd2[0]) //
//		DI.Port3_air.para8.fanspeed = espd2;
//	else if(Motorpara.Spd_Output[0]==Motorpara.Spd3[0]) //
//		DI.Port3_air.para8.fanspeed = espd3;

//	if(Motorpara.Spd_Output[0]==Motorpara.Spd_Sleep[0])  //风速一档和睡眠档位一样
//	{
//		if(DI.Port3_air.para7.opmode == emodeSleep)
//		{
//			DI.Port3_air.para8.fanspeed = espdSleep;
//		}
//		else
//		{
//			DI.Port3_air.para8.fanspeed = espd1;
//		}
//	}
	switch (DI.reqopID)
	{
		case ID_Initial:
			fInitial_Portprocess();
			break;
		case ID_Putprops:
			DI.reqPort = tRxBuffer[5];
			fPut_Portprocess(DI.reqPort);								
			break;
		case ID_Getprops:
			DI.reqPort = tRxBuffer[5];
			if(DI.Status == 0)
			{
				if(DI.rxPayloadLenth!=1)  //假如数据个数不为1
				{
					DI.Status = 0x0c; //非法数据
				}
				else
				{
					DI.Status = 0; //合法数据
				}
			}
			fGet_Portprocess(DI.reqPort);
			break;
		default:
			DI.reqPort = tRxBuffer[5];
			if(DI.Status==0)
			{
				if(DI.reqopID<1 ||DI.reqopID>13)
					DI.Status= 0x07;  //no such reqopID
				else
					DI.Status = 0x04; // reqopID not implemented
			}
			memset(&tTxBuffer[0],0,sizeof(tTxBuffer));
			DI.txPayloadLenth = 0X0003;
			tTxBuffer[0] = 0xfe;
			tTxBuffer[1] = 0xff;
			tTxBuffer[2] = ID_Response;
			if(DI.reqopID == ID_ChangeIndication)
			{
				tTxBuffer[2] = ID_ChangeIndicationResponse;
			}
			tTxBuffer[3] = 0x00;
			tTxBuffer[4] = 0x03;
			tTxBuffer[5] = DI.Status;
			tTxBuffer[6] = DI.reqPort ;
			tTxBuffer[7] = 0x00;
			DI.CRC = fCRC16_cal(&tTxBuffer[5], DI.txPayloadLenth);
			tTxBuffer[8]=DI.CRC>>8;
			tTxBuffer[9] =DI.CRC&0xff;
			R_SCI_UART_Write(&g_uart2_ctrl, &tTxBuffer[0], 10);
			break;
	}
}

void fWifi_Ctrl(void)
{
	u16 a,b=0;
	u16 sPayloadLenth = 0;  //数据个数
	switch (WIFI_CommVars.Step)  // wifi通信的步骤
    {
    case 0: //正在接收数据
        WIFI_CommVars.DelayCnt++;
        if (WIFI_CommVars.DelayCnt >= 8)  // 只要超时25MS以上 就认为本次数据接收完成
        {
			WIFI_CommVars.DelayCnt = 0;
            WIFI_CommVars.RxLength = (RTxData_Max-g_uart2_ctrl.rx_dest_bytes); // 接收到的数据长度
            WIFI_CommVars.RxPayloadLength = WIFI_CommVars.RxLength-7;
            g_uart2_ctrl.rx_dest_bytes = RTxData_Max; //  该变量是从最大值往下减的
            g_uart2_ctrl.p_rx_dest = &tRxBuffer[0];  //入口地址重新赋值
            WIFI_CommVars.Step = 1; // 接收完成
        }

        break;

    case 1: // 接收完成，解析数据
        if((tRxBuffer[0]== 0xfe)&&(tRxBuffer[1] == 0xff))  //帧头正确
        {
            if(((tRxBuffer[3]<<8)|tRxBuffer[4]) == WIFI_CommVars.RxPayloadLength) //字节数目正确
            {
				a=fCRC16_cal(&tRxBuffer[5],WIFI_CommVars.RxPayloadLength);
				b=((tRxBuffer[WIFI_CommVars.RxLength-2]<<8)|tRxBuffer[WIFI_CommVars.RxLength-1]);
                if(fCRC16_cal(&tRxBuffer[5],WIFI_CommVars.RxPayloadLength) ==((tRxBuffer[WIFI_CommVars.RxLength-2]<<8)|tRxBuffer[WIFI_CommVars.RxLength-1])) //校验正确
					DI.Status = 0;
				else
					DI.Status= 0x01;

				DI.rxPayloadLenth = WIFI_CommVars.RxPayloadLength;
				if(DI.Status==0) //校验正确
				{
					Sys.WifiCommtimeoutcnt = 0; // 清除通讯超时
				}
                fWifi_Dataprocess();// 解析函数

            }
        }
       // memset((u8*)tRxBuffer,0,sizeof(tRxBuffer));
        WIFI_CommVars.Step = 2;

        break;

    case 2: // 发送对应数据
//			if (RestWifiFlag) // 复位wifi模块
//			{
//				RestWifiFlag = 0;
//				if (WifiDispStatus !=WifiConnecting)
//				{
//					WifiDispStatus=WifiUnConnect;
//				}
//				WifiShutCnt=0;//复位情况下，图标显示计时重新开始
//				WIFI_CommVars.TxLength = 12; // 发送12个字节
//				ArrayCpy(tTxBuffer, CmdString_Rest, 12);
//			}
//			else
//			{
//				WIFI_CommVars.TxLength = 18; // 发送18个字节
//				WritetTxBuffer(); // 发送机器状态数据
//			}
//			StartSend();
        WIFI_CommVars.Step = 3;
        //      if (WIFI_CommVars.RxDoneFlag) //接收完成
        //      {//检查接收数据是否正确
        //        if(((tRxBuffer[1] == WIFI_CommVars.Addr) ||(tRxBuffer[1] == 0))&&(0 == CheckSum(tRxBuffer, PACKAGE_SIZE)))
        //        {
        //          CheckTimeOut(FALSE);  //超时计时清零
        //          ReadtRxBuffer(); //读取接收数

        //          break;
        //        }
        //      	}

        break;
    case 3: // 等待发送完成，或者说等待下一次接收中断
        if (1)
        {
            WIFI_CommVars.Step = 2; // 有复位命令立即发送
        }
        break;
    default:
        break;
    }
}

void fDeviceData_Init(void)
{
	
	u8 i = 0;
	u32 p =0x00000000; //从bootloader区域开始读取
	DI.Port1_device.para14.node0bootloaderchecksum = 0;
	DI.Port1_device.para15.node0Applicationchecksum = 0;
	fFactory_ParticleInit();   //工厂模式使用的颗粒物传感器数据先初始化
	if(Sys.FilterTestFlg)  //滤网测试模式
	{
		WifiStatutmp[0] = Sys.Wifi_EWS_DONE_flg;
		WifiStatutmp[1] = DI.Port2_wifiu.para2.connection;
		WifiStatutmp[2] = DI.Port2_wifiu.para3.setup;
	}
	else
	{
		memset(&Sys.Plugin_Cnt,0,sizeof(Sys)); //数据先全部清除

		Sys.Plugin_Cnt = 0; //上电计时清除
		Sys.Warmup30s_Cnt=0; //初始值位0 系统上电预热30S 主要是显示--- 还有PM25传感器获取读数使用

		Sys.IAQL_memvalue = 1;
		Sys.PM25_memvalue = 1; //初始化为1
		Sys.LVDcheckflg = 0;  //低电压检测默认先不开启
		
		Sys.Sleep3S_Cnt = 3; //睡眠模式下的计数初始值为3 递减
		Sys.AQI_LEVEL = 4; //AQI等级  默认全部关闭显示灯
		
		Sys.decoring = edeco_Normal;  //光圈颜色执行默认配色 该项会在后面的配置信息中重新读取
		Sys.PM25_TFa = 90;
		Sys.PM25_TFb = 273;
	}
	while(1)  // 计算设备累加和 在自检时候使用
	{
		DI.Port1_device.para14.node0bootloaderchecksum += *(u8 *)(p);
		if(++p==(0x00004000-8) )
			break;
		
	}
	p =0x00004000; //从APP区域开始读取
	while (1)
	{
		
		DI.Port1_device.para15.node0Applicationchecksum += *(u8 *)(p);
		if(++p==(0x10000-8) )
			break;
	}

	
	
	memset(&Filter.Storeflg,0,sizeof(Filter)); //数据先全部清除
	Filter.PreLifemaxhour = 720; //预置滤网最大时间
	Filter.NormalLifemaxhour = 4800; //正常普通滤网使用最大时间
	Filter.NormalLifeloweresthour = 1200; //正常普通滤网最少的使用时间
	Filter.CCMmgmax_mg = 16000; // 滤网信息  先给与一个默认值
	Filter.Flow[espdOff] = 0; //各个风速单位的Flow值
	Filter.Flow[espdSleep] = 65;
	Filter.Flow[espdTurbo] = 460;
	Filter.Flow[espd1] = 65;
	Filter.Flow[espd2] = 160;
	Filter.Flow[espd3] = 320;

	DI.rxPayloadLenth = 0x03;
	DI.reqVersion = 0X01;
	DI.serverHints = 0X00;
	DI.WiFiProtocolVersion = 0x02;
	DI.clientHints = 0x00;
		
	//-----------------------------Port1_device-----------------------------------------------------------
	DI.Port1_device.para1.Props = 0x01;
	DI.Port1_device.para1.Lenths = 0x02;
	DI.Port1_device.para1.portpollinginterval=0x00;
	
	DI.Port1_device.para2.Props = 0x02;
	DI.Port1_device.para2.Lenths = 0x01;
	DI.Port1_device.para2.category=0x0;  //0 空气净化器  1除湿器 2地板清洗器
	
	DI.Port1_device.para3.Props = 0x03;
	DI.Port1_device.para3.Lenths = strlen("AirPurifer");
	strcpy(&DI.Port1_device.para3.name[0],"AirPurifer");
	
	DI.Port1_device.para4.Props = 0x04;
	DI.Port1_device.para4.Lenths = strlen("Pluto");
	strcpy(&DI.Port1_device.para4.productrange[0],"Pluto");
	
	DI.Port1_device.para5.Props = 0x05;
	DI.Port1_device.para5.Lenths = strlen("AC0850/85");
	strcpy(&DI.Port1_device.para5.ctn[0],"AC0850/85");
	
	DI.Port1_device.para7.Props = 0x07;
	DI.Port1_device.para7.Lenths = 1;
	DI.Port1_device.para7.language = 0;  // 默认英文
	
	DI.Port1_device.para8.Props = 0x08;
	DI.Port1_device.para8.Lenths = 1;
	DI.Port1_device.para8.wifiprotocolversion = 2;
	
	DI.Port1_device.para9.Props = 0x09;
	DI.Port1_device.para9.Lenths = 1;
	DI.Port1_device.para9.OTAUprotocolversion = 1;

	if(Sys.FilterTestFlg == 0)  //非滤网测试模式的时候 清除wifi版本信息.
	{
		DI.Port1_device.para10.Props = 0x10;
		DI.Port1_device.para10.Lenths = strlen("0.0.0");
		strcpy(&DI.Port1_device.para10.wifimodulefwversion[0],"0.0.0");
	}

	DI.Port1_device.paraA.Props = 0xa;
	DI.Port1_device.paraA.Lenths = 1;
	DI.Port1_device.paraA.area = eAREA_JAPAN;

	DI.Port1_device.paraB.Props = 0xb;
	DI.Port1_device.paraB.Lenths = 1;
	DI.Port1_device.paraB.color = ecolor_white;

	
	DI.Port1_device.para11.Props = 0x16;
	DI.Port1_device.para11.Lenths = strlen("0.0.0");
	strcpy(&DI.Port1_device.para11.node0bootloaderversion[0],"0.0.0");

	if(*(u8 *)(0x3ff9) == 0x2e	&& *(u8 *)(0x3ffb)== 0x2e )
	{
		p = 0x3ff8;
		for(i=0;i<5;i++)
		{
			DI.Port1_device.para11.node0bootloaderversion[i] = *(u8 *)(p);
			p++;
		}
		DI.Port1_device.para11.node0bootloaderversion[i] = 0;
	}

	
	
	DI.Port1_device.para12.Props = 0x17;
	DI.Port1_device.para12.Lenths = strlen("0.1.0");
	strcpy(&DI.Port1_device.para12.node0applicationversion[0],"0.1.0");
	if(*(u8 *)(0xfff9) == 0x2e  && *(u8 *)(0xfffb)== 0x2e )
	{
		p = 0xfff8;
		for(i=0;i<5;i++)
		{
			DI.Port1_device.para12.node0applicationversion[i] = *(u8 *)(p);
			p++;
		}
		DI.Port1_device.para12.node0applicationversion[i] = 0;
	}


	DI.Port1_device.para13.Props = 0x18;
	DI.Port1_device.para13.Lenths = strlen("0.0.0");
	strcpy(&DI.Port1_device.para13.node0touchicversion[0],"0.0.0");


	DI.Port1_device.para14.Props = 0x19;
	DI.Port1_device.para14.Lenths = 2;
	//在开头已经初始化过了

	DI.Port1_device.para15.Props = 0x1A;
	DI.Port1_device.para15.Lenths = 2;
	
	
	//在开头已经初始化过了
	//-----------------------------Port2_wifiu-----------------------------------------------------------
	DI.Port2_wifiu.para1.Props = 0x01;
	DI.Port2_wifiu.para1.Lenths = 0x02;
	DI.Port2_wifiu.para1.portpollinginterval=0x00;

	
	DI.Port2_wifiu.para2.Props = 0x02;
	DI.Port2_wifiu.para2.Lenths = 0x01;
	
	
	DI.Port2_wifiu.para3.Props = 0x03;
	DI.Port2_wifiu.para3.Lenths = 0x01;
	
	Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
	Sys.Wifi_EWS_DONE_flg = 0;
	PWR_WIFI_EN(); // 默认打开wifi电源
	DI.Port2_wifiu.para2.connection = wifi_C_not_connected; //进入配网状态
	DI.Port2_wifiu.para3.setup = wifi_S_requested;
//	Sys.WifiEnable = 1;
	
	
	//-----------------------------Port3_air-----------------------------------------------------------
	DI.Port3_air.para1.Props = 0x01;
	DI.Port3_air.para1.Lenths = 0x02;
	DI.Port3_air.para1.portpollinginterval=0x00;
	
	DI.Port3_air.para2.Props = 0x02;
	DI.Port3_air.para2.Lenths = 0x01;
	DI.Port3_air.para2.power = 0x00;  //0x00: “OFF”  0x01: “ON”

	
	DI.Port3_air.para3.Props = 0x03;
	DI.Port3_air.para3.Lenths = 0x01;
	DI.Port3_air.para3.childLock = 0x00; //0x00: “False”(disabled)  0x01: “True”(enabled)

	
	DI.Port3_air.para4.Props = 0x04;
	DI.Port3_air.para4.Lenths = 0x01;

	DI.Port3_air.para4.AQILight = eLightNomal;
	
	DI.Port3_air.para5.Props = 0x05;
	DI.Port3_air.para5.Lenths = 0x01;
//	DI.Port3_air.para5.UIlight = 0x00; //0: Off   50: Dim    100: On  UI灯的亮度
	DI.Port3_air.para5.UIlight = eLightNomal;
	Sys.eLight20S_Cnt = 20; // 只要有按键20计时重新计算

	
	DI.Port3_air.para6.Props = 0x0B;  
	DI.Port3_air.para6.Lenths = 1;
	DI.Port3_air.para6.userautomodesetting = 0x00; // 0x00: “A”(Allergen)  0x01: “P”(Pollution)   0x02: “G”(GAS)  0x03: “F”(Formaldehyde)

	
 	DI.Port3_air.para7.Props = 0x0C;  
	DI.Port3_air.para7.Lenths = 1;
	DI.Port3_air.para7.opmode = emodeAuto;  // 0x00: “Auto General”	0x01: “Sleep” 0x02: “Turbo” 0x03: “Allergy Sleep” 0x04: “Gentle/Speed 1” 0x05: “Speed 2”

	
	
	DI.Port3_air.para8.Props = 0x0D;  
	DI.Port3_air.para8.Lenths = 1;
	DI.Port3_air.para8.fanspeed = 0x00;  //0x00: ‘0’: “Off” 0x01: ‘s’: “sleep” 0x02: ‘t’: “turbo” 0x03: ‘1’: “speed 1” 0x04: ‘2’: “speed 2” 0x05: ‘3’: “speed 3”
	
	DI.Port3_air.para9.Props = 0x20;  
	DI.Port3_air.para9.Lenths = 1;
	DI.Port3_air.para9.iaql = 1;		//0 (warmup), 1 – 12  r

	DI.Port3_air.para10.Props = 0x21;  
	DI.Port3_air.para10.Lenths = 2;
	DI.Port3_air.para10.pm25 = 1;  // 0 (warmup), 1 – 500 r
	
	DI.Port3_air.para15.Props = 0x2a;  
	DI.Port3_air.para15.Lenths = 1;
	DI.Port3_air.para15.ddp = eddpPM25;   //0x00: “IAI” 0x01: “PM2.5” 0x02: “GAS” 0x03: “Formaldehyde”  R/W

	
	DI.Port3_air.para16.Props = 0x2b;  
	DI.Port3_air.para16.Lenths = 1;
	DI.Port3_air.para16.rddp = 1; //0x00: “IAI” 0x01: “PM2.5” 0x02: “GAS” 0x03: “Formaldehyde”	R	
	
	
	DI.Port3_air.para17.Props = 0x2c;  
	DI.Port3_air.para17.Lenths = 1;
	DI.Port3_air.para17.aqit = 4;  // 1 – 12
	
	DI.Port3_air.para18.Props = 0x40;  
	DI.Port3_air.para18.Lenths = 2;
	DI.Port3_air.para18.errorcode = 0x0000;
	
	//-----------------------------Port4_fac-----------------------------------------------------------
	DI.Port4_fac.para1.Props = 0x01;
	DI.Port4_fac.para1.Lenths = 0x02;
	DI.Port4_fac.para1.portpollinginterval=0x00;
	
	DI.Port4_fac.para2.Props = 0x02;
	DI.Port4_fac.para2.Lenths = 0x01;
	DI.Port4_fac.para2.pcba = 0x0;  //0: ready   1:start  R/W

	
	DI.Port4_fac.para3.Props = 0x03;
	DI.Port4_fac.para3.Lenths = 0x01;
	DI.Port4_fac.para3.wifi = 0x00; //0: ready   1:start R/W

	
	DI.Port4_fac.para4.Props = 0x04;
	DI.Port4_fac.para4.Lenths = 0x01;
	DI.Port4_fac.para4.reset = 0x00; //0: ready   1:start R/W
	
	
	
	
//-----------------------------Port5_fltsts-----------------------------------------------------------
	DI.Port5_fltsts.para1.Props = 0x01;
	DI.Port5_fltsts.para1.Lenths = 0x02;
	DI.Port5_fltsts.para1.portpollinginterval=0x00;
	
	DI.Port5_fltsts.para2.Props = 0x02;
	DI.Port5_fltsts.para2.Lenths = 0x01;
	DI.Port5_fltsts.para2.filtertype1 = 0x3;  //0x01 – 0x09: “A1” – “A9” R

	
	DI.Port5_fltsts.para3.Props = 0x03;
	DI.Port5_fltsts.para3.Lenths = 0x01;
	DI.Port5_fltsts.para3.filtertype2 = 0; //0x01 – 0x09: “C1” – “C9”  0X00--NONE  R

	
	DI.Port5_fltsts.para4.Props = 0x07;
	DI.Port5_fltsts.para4.Lenths = 0x02;
	DI.Port5_fltsts.para4.filter0lifetime = 720; // R  

	DI.Port5_fltsts.para5.Props = 0x08;
	DI.Port5_fltsts.para5.Lenths = 0x02;
	DI.Port5_fltsts.para5.filter1lifetime= 4800;
	
	DI.Port5_fltsts.para6.Props = 0x09;
	DI.Port5_fltsts.para6.Lenths = 0x02;
	DI.Port5_fltsts.para6.filter2lifetime = 0x0;  //  R

	
	DI.Port5_fltsts.para7.Props = 0x0D;
	DI.Port5_fltsts.para7.Lenths = 0x02;
	DI.Port5_fltsts.para7.filter0remaininglifetime = 0x00; // R

	
	DI.Port5_fltsts.para8.Props = 0x0E;
	DI.Port5_fltsts.para8.Lenths = 0x02;
	DI.Port5_fltsts.para8.filter1remaininglifetime = 0x00; // R
	
	DI.Port5_fltsts.para9.Props = 0x0F;
	DI.Port5_fltsts.para9.Lenths = 0x02;
	DI.Port5_fltsts.para9.filter2remaininglifetime = 0x00; // R
	
	
	//-----------------------------Port6_flttest-----------------------------------------------------------
	DI.Port6_flttest.para1.Props = 0x01;
	DI.Port6_flttest.para1.Lenths = 0x02;
	DI.Port6_flttest.para1.portpollinginterval=0x00;  // R/W
	
	DI.Port6_flttest.para2.Props = 0x02;
	DI.Port6_flttest.para2.Lenths = 0x01;
	DI.Port6_flttest.para2.filtertype1 = 3;  //0x01 – 0x09: “A1” – “A9” R/W

	
	DI.Port6_flttest.para3.Props = 0x03;
	DI.Port6_flttest.para3.Lenths = 0x01;
	DI.Port6_flttest.para3.filtertype2 = 0x00; //0x01 – 0x09: “C1” – “C9”  0X00--NONE  R/W

	
	DI.Port6_flttest.para4.Props = 0x07;
	DI.Port6_flttest.para4.Lenths = 0x02;
	DI.Port6_flttest.para4.filter0lifetime = 720; // R/W

	DI.Port6_flttest.para5.Props = 0x08;
	DI.Port6_flttest.para5.Lenths = 0x02;
	DI.Port6_flttest.para5.filter1lifetime= 4800; // R/W
	
	DI.Port6_flttest.para6.Props = 0x09;
	DI.Port6_flttest.para6.Lenths = 0x02;
	DI.Port6_flttest.para6.filter2lifetime = 0x0;  //  R/W

	
	DI.Port6_flttest.para7.Props = 0x0D;
	DI.Port6_flttest.para7.Lenths = 0x02;
	DI.Port6_flttest.para7.filter0remaininglifetime = 0x00; //R/W

	
	DI.Port6_flttest.para8.Props = 0x0E;
	DI.Port6_flttest.para8.Lenths = 0x02;
	DI.Port6_flttest.para8.filter1remaininglifetime = 0x00; // R/W
	
	DI.Port6_flttest.para9.Props = 0x0F;
	DI.Port6_flttest.para9.Lenths = 0x02;
	DI.Port6_flttest.para9.filter2remaininglifetime = 0x00; //R/W
	
	
	DI.Port6_flttest.para10.Props = 0x13;
	DI.Port6_flttest.para10.Lenths = 0x04;
	DI.Port6_flttest.para10.filter1CCMcurrent = 0x00; // R/W

	
	DI.Port6_flttest.para11.Props = 0x14;
	DI.Port6_flttest.para11.Lenths = 0x04;
	DI.Port6_flttest.para11.filter1lifecurrent = 0x00; //R/W


	DI.Port6_flttest.para12.Props = 0x15;
	DI.Port6_flttest.para12.Lenths = 0x02;
	DI.Port6_flttest.para12.K1CountValue = 0x00; //R  //按键1 检测值

	DI.Port6_flttest.para13.Props = 0x16;
	DI.Port6_flttest.para13.Lenths = 0x02;
	DI.Port6_flttest.para13.K1ReferenceValue = 0x00; //R //按键2 检测值

	DI.Port6_flttest.para14.Props = 0x17;
	DI.Port6_flttest.para14.Lenths = 0x02;
	DI.Port6_flttest.para14.K2CountValue = 0x00; //R //按键3 检测值

	DI.Port6_flttest.para15.Props = 0x18;
	DI.Port6_flttest.para15.Lenths = 0x02;
	DI.Port6_flttest.para15.K2ReferenceValue = 0x00; //R //按键1 基准值

	DI.Port6_flttest.para16.Props = 0x19;
	DI.Port6_flttest.para16.Lenths = 0x02;
	DI.Port6_flttest.para16.K3CountValue = 0x00; //R  //按键2 基准值

	DI.Port6_flttest.para17.Props = 0x1A;
	DI.Port6_flttest.para17.Lenths = 0x02;
	DI.Port6_flttest.para17.K3ReferenceValue = 0x00; //R  //按键3 基准值
	
	
//-----------------------------Port7_network-----------------------------------------------------------
	DI.Port7_network.para1.Props = 0x01;
	DI.Port7_network.para1.Lenths = 0x02;
	DI.Port7_network.para1.portpollinginterval=0x00;
	
	DI.Port7_network.para2.Props = 0x02;
	DI.Port7_network.para2.Lenths = 6;
	memset(&DI.Port7_network.para2.macaddress[0],0,6);
	
	DI.Port7_network.para3.Props = 0x03;
	DI.Port7_network.para3.Lenths = 4;
	memset(&DI.Port7_network.para3.ipaddress[0],0,4);
	
	DI.Port7_network.para4.Props = 0x04;
	DI.Port7_network.para4.Lenths = 4;
	memset(&DI.Port7_network.para4.subnetmask[0],0,4);
	
	DI.Port7_network.para5.Props = 0x05;
	DI.Port7_network.para5.Lenths = 32;
  	memset(&DI.Port7_network.para5.wifissid[0],0,32);
	
	DI.Port7_network.para6.Props = 0x06;
	DI.Port7_network.para6.Lenths = 63;
	memset(&DI.Port7_network.para6.wifipasscode[0],0,63);
	
	
	DI.Port7_network.para7.Props = 0x07;
	DI.Port7_network.para7.Lenths = 4;
	memset(&DI.Port7_network.para7.defaultgateway[0],0,4);
	
	DI.Port7_network.para8.Props = 0x08;
	DI.Port7_network.para8.Lenths = 4;
	memset(&DI.Port7_network.para8.dhcpserver[0],0,4);
	
//-----------------------------Port8_otau-----------------------------------------------------------
	DI.Port8_otau.para1.Props = 0x01;
	DI.Port8_otau.para1.Lenths = 0x02;
	DI.Port8_otau.para1.portpollinginterval=0x00;
	
	DI.Port8_otau.para2.Props = 0x02;
	DI.Port8_otau.para2.Lenths = 0x01;
	DI.Port8_otau.para2.state=0x0;  //0x00: “idle” 0x01: “downloading” 0x02: “downloaded” 0x03: “reset”

	
	DI.Port8_otau.para3.Props = 0x03;
	DI.Port8_otau.para3.Lenths = strlen("0.1.0");
	strcpy(&DI.Port8_otau.para3.devicefirmwareversion[0],"0.1.0");
	memcpy(&DI.Port8_otau.para3.devicefirmwareversion[0],&DI.Port1_device.para12.node0applicationversion[0],6);
	
	DI.Port8_otau.para4.Props = 0x04;
	DI.Port8_otau.para4.Lenths = 0x02;
	DI.Port8_otau.para4.currentpackagenumber=0x0;
	
	DI.Port8_otau.para5.Props = 0x05;
	DI.Port8_otau.para5.Lenths = 0x02;
	DI.Port8_otau.para5.totalpackagenumber=0x0;
	
	DI.Port8_otau.para6.Props = 0x06;
	DI.Port8_otau.para6.Lenths = 128;
	memset(&DI.Port8_otau.para6.data[0],0,DI.Port8_otau.para6.Lenths);

	
	DI.Port8_otau.para7.Props = 0x07;
	DI.Port8_otau.para7.Lenths = 4;
	DI.Port8_otau.para7.checksum = 0;

	if(Sys.FilterTestFlg)
	{
		 Sys.Wifi_EWS_DONE_flg = WifiStatutmp[0];
		 DI.Port2_wifiu.para2.connection = WifiStatutmp[1];
		 DI.Port2_wifiu.para3.setup = WifiStatutmp[2];
	}
	
}
void fWifi_Timeoutcal(void) // wifi模块超时计算和控制
{
	if(Sys.WifiEnable == 0 || Sys.wifisetcnt>=3)
	{
		PWR_WIFI_DIS();  //关闭wifi 电源
		Sys.Wifi_EWS_DONE_flg = 0;
		DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
		DI.Port2_wifiu.para3.setup = wifi_S_inactive;
		return;
	}
	if((DI.Port2_wifiu.para2.connection==wifi_C_not_connected&&DI.Port2_wifiu.para3.setup==wifi_S_requested)|| \
			(DI.Port2_wifiu.para2.connection==wifi_C_not_connected&&DI.Port2_wifiu.para3.setup==wifi_S_active)||\
			(DI.Port2_wifiu.para2.connection==wifi_C_connected&&DI.Port2_wifiu.para3.setup==wifi_S_active))
	{
		if(++Sys.Wifitimeoutcnt>=wifiTimeout) // 15min时间   配网失败 关闭电源
		{
			Sys.Wifitimeoutcnt = 0;
			PWR_WIFI_DIS();  //关闭wifi 电源
			if(Sys.Wifi_EWS_DONE_flg)  //该标志位指示wifi之前是否配网成功过 根据他进入不同的状态
			{
				DI.Port2_wifiu.para2.connection = wifi_C_requested;
				DI.Port2_wifiu.para3.setup = wifi_S_inactive;	
			}
			else
			{
				DI.Port2_wifiu.para2.connection = wifi_C_not_connected;
				DI.Port2_wifiu.para3.setup = wifi_S_inactive;	
			}
		}
	}
	else
	{
		Sys.Wifitimeoutcnt = 0;
	}

	if(DI.Port2_wifiu.para2.connection==wifi_C_connected && DI.Port2_wifiu.para3.setup==wifi_S_inactive)
	{
		Sys.WifiCommtimeoutcnt++;
		if(Sys.WifiCommtimeoutcnt>=180 &&Sys.WifiCommtimeoutcnt<=185)
		{
			PWR_WIFI_DIS();  //关闭wifi 电源
		}
		else if(Sys.WifiCommtimeoutcnt>185)
		{
			PWR_WIFI_EN(); // 重启wifi电源
			if(Sys.WifiCommtimeoutcnt==365)
				Sys.WifiCommtimeoutcnt = 179;
		}
	}
}

void fLogic_ctrl(void)  //一些逻辑控制
{
	static u16 sTimecnt = 0;  // 为了不让灯来回跳 规定必须在一个阶段保持30S以上
	static u8 UIlight =  eLightNomal;
	static u8 cnt = 0;
	static u8 cnt0 = 0,cnt1 = 0;
	static u8 cnt2 = 0,cnt3 = 0;
	if(Sys.eLight20S_Cnt == 0 && DI.Port3_air.para7.opmode!=emodeSleep) //当Light唤醒20S 无动作之后 非睡眠模式下
	{
		if(Sys.lightADvalue_12bit>15)  //该数值可能还需要调整 目前比较可以的参数是 104 47K 550
			UIlight = eLightNomal;
		else if(Sys.lightADvalue_12bit>3)
			UIlight = eLightDim;
		else
			UIlight = eLightoff;
		if(UIlight!=DI.Port3_air.para5.UIlight) //当处于某个状态不改变  计时++
		{
			sTimecnt++;
		}
		else
		{
			sTimecnt = 0;
		}
		if(sTimecnt>=4000) // 20S 保持20S时间  per 5MS
		{
			sTimecnt = 0;
			DI.Port3_air.para5.UIlight = UIlight;
		}
	}
	else
	{
		sTimecnt = 0; //在确保有动作时候，这个值需要重新开始计算
	}

	if(Sys.PowerADvalue_12bit<2650) //21v AD  3210 大致是26V 电源电压
	{
		cnt0++;
		cnt1 = 0;
		if(cnt0>=200)
		{
			cnt0 = 200;
			Sys.motorpwmoutput = 0;
		}
	}
	else 
	{
		cnt1++;
		if(cnt1>=20)
		{
			cnt1 = 20;
			cnt0 = 0;
		}
	}

	if(Sys.PowerADvalue_12bit>2820) //22.5V
	{
		cnt2++;
		cnt3=0;
		if(cnt2>=200)
		{
			cnt2 = 200;
			Sys.motorpwmoutput = 1;
		}
	}
	else 
	{
		cnt3++;
		if(cnt3>=20)
		{
			cnt3 = 20;
			cnt2 = 0;
		}
	}
//	if(Filter.Time1S_Cnt>=Filter.PreLifemaxhour*3600 || Filter.Preaccumulated_hour>=Filter.PreLifemaxhour)//预置滤网报警
//		Sys.Errcode|=bit2; //F0警告
//	else
//		Sys.Errcode&=~bit2; //清除F0警告

	if(Filter.Normalaccumulated_hour>= (Filter.NormalLifemaxhour*97/100) && Filter.Normalaccumulated_hour<=Filter.NormalLifemaxhour) //普通滤网开始报警 
		Sys.Errcode |=bit3;  //F1警告 滤网重置报警
	else
		Sys.Errcode &=~bit3;   //清除F1

	if(Filter.Normalaccumulated_hour>=Filter.NormalLifemaxhour) //普通滤网寿命耗尽 需要锁机器
		Sys.Errcode |=bit4;  //F2警告 滤网锁定 机器锁定
	else
		Sys.Errcode &=~bit4;   //清除F2

	DI.Port6_flttest.para12.K1CountValue = g_touch_button_countvalue[0]; // 获取按键实时检测值
	DI.Port6_flttest.para14.K2CountValue = g_touch_button_countvalue[1];
	DI.Port6_flttest.para16.K3CountValue = g_touch_button_countvalue[2];
	DI.Port6_flttest.para13.K1ReferenceValue = g_touch_button_reference[0]; //获取按键实时基准值
	DI.Port6_flttest.para15.K2ReferenceValue = g_touch_button_reference[1];
	DI.Port6_flttest.para17.K3ReferenceValue = g_touch_button_reference[2];
	if(DI.Port3_air.para2.power != gOnoffstatus)
	{
		if(++cnt>=100)
		{
			cnt = 0;
			gOnoffstatus = DI.Port3_air.para2.power;
		}
	}
	else
		cnt = 0;
}



void fFilter_Cal(void)  //滤网相关
{
	static u8 __1s_cnt = 0;
	static u8 __1m_cnt = 0;
	
	if(DI.Port3_air.para2.power == 1 && !(Sys.Errcode&(bit0|bit4)))//开机就算在工作运行bit0为风机故障 bit4为滤网时间到锁机器
	{
		Filter.Time1S_Cnt++;
		if(Sys.FilterTestFlg==1)
		{
			Filter.Normalaccumulated_10min+=40;  //1秒钟  // 相当于6.67小时 
				// 就是40个十分钟
			if(Filter.Time1S_Cnt>=10)
			{
				Filter.Time1S_Cnt = 0;
				
			}
		}
		else
		{
			if(Filter.Time1S_Cnt>=600)  //10分钟
			{
				Filter.Time1S_Cnt = 0;
				Filter.Normalaccumulated_10min++;
				Filter.Storeflg = 1;
			}
		}
	
		
		
	}
	if(Filter.Normalaccumulated_10min>= Filter.NormalLifemaxhour*6)  //
			Filter.Normalaccumulated_10min = Filter.NormalLifemaxhour*6;
	Filter.Normalaccumulated_hour = Filter.Normalaccumulated_10min/6 ; //+(((Filter.Normalaccumulated_10min%6)!=0)?1:0)

	fFilter_PercentageCal();
	
}

void fFilter_PercentageCal(void)  //滤网百分比相关计算
{
	if( Filter.Preaccumulated_hour>Filter.PreLifemaxhour)  //预置滤网累加时间不能超过最大时间
		Filter.Preaccumulated_hour=Filter.PreLifemaxhour;
	if(Filter.Normalaccumulated_hour>Filter.NormalLifemaxhour)   //普通滤网累加时间不能超过最大时间
		Filter.Normalaccumulated_hour = Filter.NormalLifemaxhour;
//	if(Filter.CCMmgmax_mg!=0) //CCM预设值不为0 
	if(0) //CCM预设值不为0 
	{
		//CCM percentage = CCM accumulated / CCM， CCM is max value configured by factory tool 
		if(Filter.CCMaccumulated_ug>(Filter.CCMmgmax_mg*1000)) //不能超过最大值
			Filter.CCMaccumulated_ug=(Filter.CCMmgmax_mg*1000);
		Filter.CCMremaining_mg = Filter.CCMmgmax_mg-(Filter.CCMaccumulated_ug)/1000; //微克变成毫克
		Filter.CCMpercentage = (Filter.CCMaccumulated_ug)*10/(Filter.CCMmgmax_mg); //放大10000倍 本来是 CCM percentage = CCM accumulated / CCM
		if(Filter.CCMpercentage>=10000)
			Filter.CCMpercentage = 10000;
		
		//TLSL percentage = filter timer / TLSL	Timing lower spec limit  //至少能使用的时间 无论多脏
		Filter.TLSLpercentage = (Filter.Normalaccumulated_hour*10000) /Filter.NormalLifeloweresthour;
		if(Filter.TLSLpercentage>=10000)
			Filter.TLSLpercentage = 10000;

		//TUSL percentage = filter timer / TUSL  Timing upper spec limit   //最大能使用的时间  无论多干净
		Filter.TUSLpercentage = (Filter.Normalaccumulated_hour*10000)/Filter.NormalLifemaxhour;
		if(Filter.TUSLpercentage>=10000)
			Filter.TUSLpercentage = 10000;

		/*
		
		CCM percentage < TUSL percentage     	TUSL percentage
		CCM percentage > TLSL percentage	   TLSL percentage
		CCM percentage >= TUSL percentage and
		CCM percentage <= TLSL percentage	CCM percentage
		*/
		if(Filter.CCMpercentage<Filter.TUSLpercentage)
			Filter.Disppercentage = Filter.TUSLpercentage;
		else if(Filter.CCMpercentage>Filter.TLSLpercentage)
			Filter.Disppercentage = Filter.TLSLpercentage;
		else
			Filter.Disppercentage = Filter.CCMpercentage;
	
	}
	else  // (If CCM set 0, Only Use filter life time to run)
	{
		//TUSL percentage = filter timer / TUSL  Timing upper spec limit   //最大能使用的时间  无论多干净
		Filter.TUSLpercentage = (Filter.Normalaccumulated_hour*10000)/Filter.NormalLifemaxhour;
		if(Filter.TUSLpercentage>=10000)
			Filter.TUSLpercentage = 10000;
		Filter.Disppercentage = Filter.TUSLpercentage;
	}


	DI.Port6_flttest.para4.filter0lifetime=DI.Port5_fltsts.para4.filter0lifetime = Filter.PreLifemaxhour; // 预置滤网上限时间
	DI.Port6_flttest.para5.filter1lifetime=DI.Port5_fltsts.para5.filter1lifetime = Filter.NormalLifemaxhour; // 普通滤网最大上限时间
	DI.Port6_flttest.para7.filter0remaininglifetime = DI.Port5_fltsts.para7.filter0remaininglifetime =Filter.PreLifemaxhour -Filter.Preaccumulated_hour; // 预置滤网剩余时间计算 
	DI.Port6_flttest.para8.filter1remaininglifetime=DI.Port5_fltsts.para8.filter1remaininglifetime =Filter.NormalLifemaxhour*(10000-Filter.Disppercentage)/10000; //普通滤网剩余时间计算
	DI.Port6_flttest.para10.filter1CCMcurrent = Filter.CCMaccumulated_ug/1000;  // CCM当前累计使用的量
	DI.Port6_flttest.para11.filter1lifecurrent = Filter.Normalaccumulated_hour;  //主过滤网累计使用时间

	Filter.Normalremaining_hour = DI.Port5_fltsts.para8.filter1remaininglifetime;  //便于仿真时候观测
	Filter.Preremaining_hour = DI.Port5_fltsts.para7.filter0remaininglifetime;
}

u16 fFan_FBDataCal(u16 *CntBuf) // 根据存储的反馈值  计算得到实际的转速
{
	u32 sum = *CntBuf;//把数组0下标先加上
	u16 max = *CntBuf;
	u16 min = *CntBuf;
	u8 i = 10;

	while(--i)//这里只做9次减少循环
	{
		if(*(CntBuf + i) > max)
			max = *(CntBuf + i);
		if(*(CntBuf +i) < min)
			min = *(CntBuf + i);
		sum += *(CntBuf + i);
	}
	return ((u16)((sum - max - min) >> 3));
	
	
}

void fFanFeedBackCalc(void)
{
	FG.Cnt++;
	if(FG.Cnt > 4800)//小于100rpm
	{
		FG.Cnt = 0; //清零，重新计数
		FG.CalCnt = 0;  //按0转
		FG.CycleCnt = 0;
		Sys.FanspeedFB = 0;
		return;
	}

//		if(Pin_CheckMotor)//读取反馈端口的电平
//		{//高电平
//			FG.Cnt_H++;
//			if(FG.Cnt_H>=4)
//			{
//				FG.Cnt_H = 4;
//				FG.Cnt_L = 0;
//			}
//			if(FG.State)
//			{
//				FG.State = 0;//防止重复计数
//				
//			}
//		}
//		else
//		{
//			FG.Cnt_L++;
//			if(FG.Cnt_L>=4)
//			{
//				FG.Cnt_L = 4;
//				FG.Cnt_H = 0;
//				if(FG.State == 0)
//				{
//					if(FG.CycleCnt==0)  //从新开始计算
//					{
//						FG.Cnt = 0;
//					}
//					FG.State = 1;
//					FG.CycleCnt++;
//					if(FG.CycleCnt>=2)
//					{
//						FG.CycleCnt = 1;
//						FG.CalCnt = FG.Cnt*15;
//						FG.Cnt = 0;
//						if(FG.CalCnt<=160)
//							FG.CalCnt = 160;
//						Sys.FanspeedFB = 480000/FG.CalCnt;
//					}
//				}
//			}
//			
//		}
	if(Pin_CheckMotor)//读取反馈端口的电平
	{//高电平
		if(FG.State)
		{
			FG.State = 0;//防止重复计数
			FG.CycleCnt++;
		}
	}
	else
	{
		if(FG.State == 0)
		{
			FG.State = 1;
			FG.CycleCnt++;
		}
	}
	if(FG.CycleCnt >= 30)//直流风机有15个周期反馈，高低电平变化30次
	{
		FG.CycleCnt = 0;
		if(FG.Cnt < 160)//大于3000rpm
			FG.Cnt = 160;
		FG.CalCnt = FG.Cnt;
		FG.Cnt = 0;
		Sys.FanspeedFB = 480000/FG.CalCnt;
//		if(++FG.Index >= 10)
//			FG.Index = 0;//完成循环
//		FG.Buf[FG.Index] = FG.CalCnt;//把最新的赋值给最老的
//		FG.Cnt = 0;//清零，重新计数
//		Sys.FanspeedFB = (u16)(480000/fFan_FBDataCal(FG.Buf));
//		 = 480000/FG.CalCnt;
	}

	
}

void fFan_FBStore(void)  //存储得到的反馈值  以便在接下来的程序中使用 这个反馈值是一转的计数
{
	if(++FG.Index >= 10)
		FG.Index = 0;//完成循环
	FG.Buf[FG.Index] = FG.CalCnt;//把最新的赋值给最老的
	FG.Cnt = 0;//清零，重新计数
}





void fLightsensor_check(void)  // 总时间 大概是4.68us 2021.09.26
{
	static u16 tLightADtable[66]={0};
	static u8 i = 0;
	static u16 Max =0;
	static u16 Min = 0;
	static u32 ADtmp = 0;
	R_ADC_ScanStart(&g_adc_ctrl);   //开始采样到获得数据 大概2.1us 2021.09.26
	fDelay_us(4);
	R_ADC_Read(&g_adc_ctrl, ADC_CHANNEL_6, &Sys.lightADvaluetmp_12bit);  //得到的是12位的数据
	Sys.lightADvalue_10bit = Sys.lightADvaluetmp_12bit>>2;
	tLightADtable[i] = Sys.lightADvaluetmp_12bit;
	ADtmp+=tLightADtable[i];
	if(i == 0)
	{
		Max = tLightADtable[0];
		Min = tLightADtable[0];
	}
	if(Sys.lightADvaluetmp_12bit>Max)
		Max = Sys.lightADvaluetmp_12bit;
	if(Sys.lightADvaluetmp_12bit<Min)
		Min = Sys.lightADvaluetmp_12bit;
	if(++i>=66)
	{
		
		ADtmp = ADtmp- (Max+Min);
		
		Sys.lightADvalue_12bit = ADtmp>>6;
		ADtmp = 0;
		i = 0;
		Max = 0;
		Min = 0;
	}
	R_ADC_ScanStart(&g_adc_ctrl);   //开始采样到获得数据 大概2.1us 2021.09.26
	fDelay_us(4);
	R_ADC_Read(&g_adc_ctrl, ADC_CHANNEL_0, &Sys.PowerADvalue_12bit);  //得到的是12位的数据
	
	
}







/*
2021.10.21
1.在2021.10.21的 TL_NALA 030版本程序上修改为TL2828.

AN00  AD电压检测  AN06 光敏

2021.10.23
1.更新电机部分，调节占空比来调节风速

2021.10.24
1.在之前的基础上修改PWM输出的程序，PWM输出不是0的情况下，也未超过Period,会输出寄存器的值。查找关键字	DWC
2.基本显示功能更新。

2021.10.26
1.继续修改，主要涉及wifi方面。 PORT5 PORT62
2.PORT2 增加RSSI  应该是wifi信号强度吧  

2021.10.27
1.根据电机厂给出的占空比转速表格，微调下风速控制部分.
2021.10.28
1.修改LED驱动部分
2.修改为PID调速试试

2021.11.01
1.在29号基础上，修改开关机现在直接就开关机，睡眠模式下也直接开关机

2021.11.08
1.微调按键阈值，微调三额档位的灯的亮度.

2021.11.25
1.新更新wifi协议。具体为增加country 和color 在PORT1 清除RSSI 在port2
2.增加一个掉电记忆 记忆配网次数

2021.12.05
1.默认wifi电源开启，更新RASC，然后新生成的的Pin_data.h文件 默认把015置位高电平.
2.版本为初始010
3.现在PM2.5数值大于等于400，直接变为500.

2021.12.08
1.CTN 固定为AC0850/85
2.新增加工厂模式
3.增加对24V电压的AD检测来控制PWM上是否需要输出 21V以下关闭单元，频率输出低 22.5V以上再开启
4.滤网加速模式更改为一秒钟等于6.67小时，和规格书一致.
5.现在电源和功能按键可以同时触发组成组合键，上电30S内可以进入自检.
6.现在按键的检测阈值应该对了

2021.12.10
1.修复滤网信息读取不正确的问题

2021.12.13
1.修复滤网寿命的问题，4799小时多几个十分钟的的时候 直接就报4800了
2.现在使能蜂鸣器功能 4KHZ
3.解决重复响应关机的问题
4.market 和 usermodesetting 现在默认都是alergen
5.更新2828的TFA TFB数据和TL2837的一致
6.将按键数据改回之前的键值和基准值
7.修复自检时候 风机不报故障的问题，增加PM2.5传感器的故障报警
8.开机3秒现在变为两个循环，之前为一个
9.30S预热时间改为保持蓝色灯常亮
10.自检最后一步改为按开关键
11. 现在进工厂模式和滤网测试模式都需要在上电10S内 按相对应的按键5S时间进入
12.调整触摸和定时器中断的中断向量表位置..
2021.12.14
1.在13号程序的基础上调整按键.
2.自检里面增加进入快速滤网模式.
3.修复发送异常模式代号造成的风速不匹配问题
4.简单的做个参数边界判断。主要是接收wifi命令.(原先有做判断，现在修改一下边界)
5.产测内长按模式按键可以直接退出自检进入快速滤网检测.
6.快速滤网检测的时候，三色灯闪烁显示.
7.增加自检时候的按键蜂鸣器

2021.12.15   020
1.现在在自检橙色灯闪烁时增加一步，在这一步时候可以进入快速滤网模式，而不触发wifi自检.

2022.01.06  030
1.飞利浦要恢复光耦的功能，光耦的几个参数参照NaLa，要写出来
2：电机控制以20转，要加入10转迟滞。这样避免来回跳动。
3：进入工厂模式长按3S，
这几点加入下规格书中，程序同时改。。
4.修复按键数组清除个数不对的问题.应该为u16*个数
5.修复滤网报警时候RB1灯也亮的问题
6.修复了没有强制滤网时间清除以及显示的问题

2022.02.16
1.在0106程序的基础上把颜色调整为之前020改颜色之后的数据.
2.风速略微调整，放慢调整速度
3.自检时候的橙色灯和白色灯亮的bug的修复
4.自检时候中间会 清除wifi信息.
5.产测的时候，显示亮度改为最亮.主要是因为LED驱动里面全关了LED灯 只要在产测模式下禁用就好了.

2022.02.22
1.修复产测模式下不明灯亮的问题。未在最开始清除LED灯光。
2.天瑞的正常配置信息之后现在会显示国家选项。
3.现在未配置信息的情况下不会存储数据。，防止het产测之后按按键结束会存储不正确的配置信息。
4.修复产测模式下，风机或者传感器故障有其他灯微亮的bug.
5.修复产测模式在最后的几步如果遇到风机或者传感器故障，能继续往下走的问题。
6.现在产测下无法进入快速滤网模式。

2022.02.23
1.缩短从静止到Turbo的电机提速时间.
2.现在风速稳定的判断有个1S时间的连续，才能认定风速稳定或者不稳定.
*/
void hal_entry(void)
{
    /* TODO: add your own code here */
	__enable_irq();
	qe_Touch_close();  //先把按键关闭
    __disable_irq(); //清除 PRIMASK 屏蔽所有中断
    fSystem_Init(); //系统初始化
	fDelay_us(0xff);  //延时一段时间
    fDeviceData_Init();  //设备数据初始化
	fMemory_Read();  //掉电记忆E方数据读取和处理
	#if PM25LIB
	pmInit(market,Sys.PM25_TFa,Sys.PM25_TFb); // PM2.5传感器初始化
	#endif
   	__enable_irq(); //开启全部中断	
   	gOnoffstatus = DI.Port3_air.para2.power; // 先把两者赋同样的值
	// Sys.Setupflg = 2;
	#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
	
    while (1)
    {
        R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
        if(gTime5msflg)
        {
            gTime5msflg = 0;
			if(Sys.Factoryflg)  // 工厂模式
				fFactory_Key_Process();  //产测模式时候的按键处理
			else
				fKey_Process();  // 按键处理函数  键值获取需要2ms时间			
			fWifi_Ctrl();  //wifi控制		
			fLogic_ctrl();  //一些逻辑控制 需要更新速度比较快的	
			if(Sys.Factoryflg==0) //非工厂模式
				fDisp_Ctrl();  //显示设置  5Ms
        }
        if(gTime100msflg&bit1)  //per 100MS 不执行掉电记忆擦除的时候只需要300US执行时间 擦除需要5ms左右
        {
            gTime100msflg &=~bit1;
			fMotor_Ctrl();  //电机控制
			fMemory_Deal();  // 掉电记忆处理
        }
        if(gTime1sflg&bit0)  //执行需要29.7US 时间
        {
            gTime1sflg &= ~bit0 ;
			if(Sys.Factoryflg==0)  
				fParticleGet();//颗粒物传感器函数需要在非产测模式下进入
			fFilter_Cal();  //滤网寿命计算
			fWifi_Timeoutcal(); //wifi超时计算  15min
			if(Sys.LVDcheckflg == 0)  //上电过一段时间之后 电压稳定了才会开启LVD
			{
				Sys.LVDcheckflg = 1;
				R_LVD_Open(&g_lvd_ctrl, &g_lvd_cfg); //开启低电压检测  下降沿有效	
			}	
        }
		
    }
}

void fDeviceSys_Init(void) //设备的所有参数 除了配置信息完请全初始化
{
	fFLASH_ERASE(FLASH_BLOCK1_FILTER_4000); //清除滤网记忆信息
	fFLASH_ERASE(FLASH_BLOCK2_SYSSTATUS_8000); //清除系统状态信息
	fFLASH_ERASE(FLASH_BLOCK3_PORT1DEVICE_C000); //清除PORT1的设备信息
	
	fFilterWorkedDataInit();    //滤网信息复位初始化
//   	fDeviceData_Init();  //设备的一些信息初始化 包括初始化每一个port的数据
//  	if(Sys.Setupflg ==2) //主要给滤网测试和自检时候使用
 //		fMemory_Read();  //掉电记忆E方数据读取和处理 主要是读取配置信息
}

void fData_config(void)
{	
	volatile u16 datatmp = 0;
	volatile u16 adtmp = 0;

	fLightsensor_check(); //未配置或者待机上电15秒之内1MS检测一次

	adtmp = Sys.lightADvalue_10bit;
	if(adtmp<800)
		adtmp=100;
	if(Photosensitive_scan(adtmp>>1))  
	{
		if(memcmp(&Pho.Rec_data[0],&tCommand_Dataconfig[0],4)==0) //和命令数组做比对 完全一样的话 返回0
		{
			datatmp=fCRC16_cal(&Pho.Rec_data[3], Pho.Rec_data[2]);  //计算校验和
			if(datatmp == ((Pho.Rec_data[Pho.Rec_data[2]+3]<<8)|Pho.Rec_data[Pho.Rec_data[2]+4])) //CRC
			{	
				fhex2chr(&DI.Port1_device.para5.ctn[2], &Pho.Rec_data[4], 2);  //获取CTN;
				fhex2chr(&DI.Port1_device.para5.ctn[7], &Pho.Rec_data[6], 1);  //获取CTN;
				if(Pho.Rec_data[4]==0 &&Pho.Rec_data[5]==0&&Pho.Rec_data[6]==0) // FCT2 不清除那些已经获取的数据
					;
				else
				{
					fDeviceData_Init();  // 只要是重新配置  都先初始化数据  下面会清除记忆 重新写入数据
					
				}
				if(Pho.Rec_data[7]&bit0) //市场只能2选1 
				{
					market =INDIA_MARKET;  //
				}
				else
				{
					if(Pho.Rec_data[7]&bit4)
						market = ALLERGEN_MARKET; //
					else
						market = POLLUTION_MARKET; //
				}
				if(Pho.Rec_data[7]&bit1) // user prefered
					DI.Port3_air.para6.userautomodesetting = 1;// Pollution
				else
					DI.Port3_air.para6.userautomodesetting = 0; //ALLERGEN	

				if(Pho.Rec_data[7]&bit2)
					DI.Port3_air.para15.ddp = eddpPM25; //PM25
				else
					DI.Port3_air.para15.ddp = eddpIAI;// IAI
				DI.Port3_air.para16.rddp = DI.Port3_air.para15.ddp;

//				if(Pho.Rec_data[7]&bit3)
//					Sys.decoring = edeco_Pink; //选择粉色
//				else
//					Sys.decoring = edeco_Normal;//选择正常颜色

				

				if(Pho.Rec_data[7]&bit5)
					Sys.WifiEnable = 1; // 开启wifi功能
				else
					Sys.WifiEnable = 0; //关闭wifi功能

				if(Pho.Rec_data[7]&bit6)
					Sys.Economic = 1; // 开启jd ECONOMIC
				else
					Sys.Economic = 0; //关闭

				if(Pho.Rec_data[7]&bit7)  //最小使用年限
					Filter.NormalLifeloweresthour = 2400*2;  //1年
				else
					Filter.NormalLifeloweresthour = 2400*1;	//半年

				Motorpara.Spd_Turbo[1]	=	Pho.Rec_data[8]*10;  //改变turbo 速度 10倍
				Motorpara.Spd_Turbo[0] =	Motorpara.Spd_Turbo[1];  //风速控制用的值先放大10倍
				Filter.NormalLifemaxhour = ((Pho.Rec_data[9]>>5)+ 1)*2400;  //最大使用年限
				Filter.CCMmgmax_mg= 4000* (Pho.Rec_data[9]&0x1f);  //单位是毫克
				
				DI.Port1_device.paraA.area =Pho.Rec_data[10]; //系数
				DI.Port1_device.paraB.color =Pho.Rec_data[11];
				Sys.PM25_TFa = (signed int)(Pho.Rec_data[12]<<8)+(signed int)Pho.Rec_data[13];
				Sys.PM25_TFb = (signed int)(Pho.Rec_data[14]<<8)+(signed int)Pho.Rec_data[15];
				Motorpara.Spd_Sleep[1]	=	Pho.Rec_data[16]*10;  //改变sleep 速度 10倍
				Motorpara.Spd_Sleep[0] = Motorpara.Spd_Sleep[1];  //风速控制用的值先放大10倍
				Sys.checksumOption = 0;
				for(datatmp=4;datatmp<(Pho.Rec_data[2]+3);datatmp++) //计算有效数据的累加和
				{
					Sys.checksumOption += Pho.Rec_data[datatmp];
				}
				Sys.checksumOption&=0x00ff;
				Sys.Setupflg = 1; // 配置成功 但是当配置刚完成的时候，机器还无法使用 必须掉电才行	
				if(Pho.Rec_data[4]==0 &&Pho.Rec_data[5]==0&&Pho.Rec_data[6]==0)
				{
					Sys.Plugin_Cnt = 30;
					if(Sys.Factoryflg == 0)
					{
						ffacstart();
					}
				}
				else
				{
					
					fFLASH_WRITE(FLASH_BLOCK0_DATACONFIG_0000,&Pho.Rec_data[0], Pho.Rec_data[2]+5); //将配置数据写入E方
					fDeviceSys_Init(); //系统参数初始化
				}
				Buz_Twice();
//						sprintf(&DI.Port1_device.para5.ctn[2],"%s",tTmp[0]);
			}
		}
		
//		if(1)  //调试使用
		if(Sys.Setupflg ==2)  //和客户确认 这两个功能必须在标定信息之后才能使用
		{
			if(memcmp(&Pho.Rec_data[0],&tCommand_Factory[0],7)==0)  //一样时
			{
				ffacstart();
			}
			if(memcmp(&Pho.Rec_data[0],&tCommand_Filtertest[0],7)==0)  //比对命令数组
			{

				Sys.wifisetcnt = 0; // 次数清除
				Sys.Factoryflg = 0;
				DI.Port3_air.para2.power = 1;  //滤网测试模式 开机
				Sys.FilterTestFlg = 1; // 滤网测试模式
				PWR_WIFI_EN();  // 开启wifi电源
				Sys.Wifitimeoutcnt = 0; //wifi配网超时时间重新开始计算
				fDeviceSys_Init(); //系统参数初始化

				Buz_Twice();	
			}
		}
		
	}
}
void Timer_1ms(timer_callback_args_t * p_args)  //21us 左右的时间  2021.09.26
{
    static u16 sT1mscnt=0;
			
	if(DI.Port3_air.para10.pm25 == 0)  //防止显示0  至少显示1
		DI.Port3_air.para10.pm25 = 1;
	if(DI.Port3_air.para9.iaql == 0)
		DI.Port3_air.para9.iaql = 1;
	if(Sys.FilterTestFlg && DI.Port3_air.para2.power==0) //只要关机 就退出滤网测试模式
	{
		fDeviceData_Init();  //设备的一些信息初始化 包括初始化每一个port的数据
		fMemory_Read();  //掉电记忆E方数据读取和处理 主要是读取配置信息
		fFilterWorkedDataInit();
		
		Sys.FilterTestFlg = 0;  //退出滤网测试模式	
	}
    sT1mscnt++;
	if((sT1mscnt%5)==0)
		gTime5msflg = 1;
    if((sT1mscnt%100)==0)
    {
        gTime100msflg = 0x0f;
		if(Filter.Forcereset_3S_Cnt)
			Filter.Forcereset_3S_Cnt--;
		if(++Sys.Plugin_Cnt>=600)  //上电计数  每100ms 累加一次
			Sys.Plugin_Cnt = 600;
		if(Sys.Setupflg<2)  // 未配置设备 开或者配置刚完成
		{
			if(Sys.Plugin_Cnt>=30)
				Sys.Plugin_Cnt = 31;
		}
		if(DI.Port3_air.para2.power&&(Sys.Plugin_Cnt>30)) // 只有开机条件下 30S 计时才能进行，并且要在开机全亮3秒之后
		{	
			if(++Sys.Warmup30s_Cnt>=600)
				Sys.Warmup30s_Cnt=600;
			
		}
    }
	if((sT1mscnt%500)==0)
	{
		gFre1hzflashflg^=1;  //1HZ频率  0.5S取反
		gTime500msflg = 1;
	}

    if((sT1mscnt%1000)==0)
    {
		gFre0_5hzflashflg ^=1;
        gTime1sflg = 0xff;

		if(DI.Port3_air.para2.power ) //开机状态下就可以进行
		{
			if(Sys.eLight20S_Cnt>0&&Sys.eLight20S_Cnt<21)
				Sys.eLight20S_Cnt--;
		}
		

		
		if(DI.Port3_air.para7.opmode==emodeSleep && DI.Port3_air.para2.power) //处于开机并且在睡眠模式下
		{
			if(Sys.Sleep3S_Cnt&&(KeyStatus&KEY_Release)) //按键放开的情况下才能减
				Sys.Sleep3S_Cnt--;
		}
		else
		{
			Sys.Sleep3S_Cnt = 3;
		}
		
    }
   	if(DI.Port3_air.para7.opmode==emodeSleep && DI.Port3_air.para2.power) //处于开机并且在睡眠模式下
   	{
		if(Sys.Sleep3S_Cnt == 0)
		{
			DI.Port3_air.para5.UIlight = DI.Port3_air.para4.AQILight=eLightoff;
		}
		else
		{
			if(DI.Port3_air.para5.UIlight == eLightoff)
				DI.Port3_air.para5.UIlight= DI.Port3_air.para4.AQILight=eLightNomal;
		}
   	}
	if(Sys.Plugin_Cnt<=300)   //上电30S之内可以进入
	{
		fData_config(); //数据配置 如果没有配置数据 机器不允许运行
	}
	else  //检测66次 取平均值 
	{
//		 if((sT1mscnt%100)==0) //正常情况下AF值100ms 检测一次
		 fLightsensor_check(); //检测光敏AD值
	}

	 if(sT1mscnt>=1000)
        sT1mscnt = 0;
	if(Sys.Factoryflg) //工厂模式
		fFacmode_Disp_Ctrl();
	fBuz_Driver(eBuzSta);  //蜂鸣器驱动 1MS一次
	
}

void LVD_Detection(lvd_callback_args_t * p_args) //低电压检测 下降沿有效
{
	u32 Addr = 0;
	u8 datalen = 0;
	u8 i = 0;
	u16 datatmp = 0;
	u8  t_src[TRANSFER_LENGTH]= {0};
	qe_Touch_close(); //关闭按键
	while(1)
	{
		if(Sys.LVDcheckflg==1) //已经开启低电压复位
		{
			Sys.LVDcheckflg = 2;  //进入低电压复位
			PWR_MOTOR_DIS();  // 先关闭这些负载 然后
			LED_Ring_Dis();
			PWR_PM25_DIS();
			PWR_WIFI_DIS();
				
			Addr = FLASH_FILTER_400;
			do
			{
				R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
				memset(&t_src[0],0,sizeof(t_src)); //缓存数据数组清除
				for(i=0; i<7; i++) //获取数据参数2个参数 两个针头 一个数据长度 两个CRC
			    {
			        t_src[i] = *((uint8_t *)(Addr+i));
			    }
				Addr+=512;
				if(t_src[0]==0xfe &&t_src[1]==0xff)
				{
					datalen = t_src[2];
					datatmp=fCRC16_cal(&t_src[3], datalen);
					if(datatmp == ((t_src[datalen+3]<<8)|t_src[datalen+4]))
					{
						break;
					}
					
				}

				if(Addr>FLASH_FILTER_600)  //执行到这里说明滤网数据都是错误的，需要保存当前数据
				{
					if(Sys.Factoryflg==0 && Sys.FilterTestFlg==0) //非测试状态才会记忆.
					{
						i = 0;
						memset(&t_src[0],0,sizeof(t_src));
						t_src[i++] = 0xfe;
						t_src[i++] = 0xff;
						t_src[i++] = 0x2;
						memcpy(&t_src[i],&Filter.Normalaccumulated_10min,2);

						datatmp=fCRC16_cal(&t_src[i], 2);
						i+=2;
						t_src[i++] = datatmp>>8;
						t_src[i++] = datatmp&0xff;
						R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
						fFLASH_WRITE(FLASH_BLOCK1_FILTER_4000,&t_src[0],i); //FLASH_BLOCK1_FILTER_4000  
					}
				}
			}
			while (Addr<=FLASH_FILTER_600);
			i = 0;
			R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
			if(DI.Port3_air.para2.power)
			{
				memset(&t_src[0],0,sizeof(t_src));
				Sys.IAQL_memvalue = DI.Port3_air.para9.iaql;
				Sys.PM25_memvalue = DI.Port3_air.para10.pm25; //掉电之前记忆当前数据
				t_src[i++] = 0xfe;
				t_src[i++] = 0xff;
				i++;  //这边本来是个数 放到下面去填写  
				if(Sys.Wifi_EWS_DONE_flg==0 && Sys.wifisetcnt<3)
					Sys.wifisetcnt++;
				if(Sys.Wifi_EWS_DONE_flg)
					Sys.wifisetcnt = 0;
				t_src[i++] = Sys.wifisetcnt; // wifi配置次数
				t_src[i++] = Sys.Wifi_EWS_DONE_flg; //wifi使用
				if(Sys.FilterTestFlg)
					t_src[i++] = 0;
				else
					t_src[i++] = DI.Port3_air.para2.power;
				t_src[i++] = DI.Port3_air.para17.aqit;
				t_src[i++] = Sys.IAQL_memvalue; //IAI的当前值
				t_src[i++] = (Sys.PM25_memvalue>>8)&0xff; //PM25的当前值 MSB
				t_src[i++] = Sys.PM25_memvalue&0xff; //PM25的当前值 LSB
				t_src[i++] = DI.Port3_air.para3.childLock;
				t_src[i++] = DI.Port3_air.para4.AQILight;
				t_src[i++] = DI.Port3_air.para5.UIlight;
				t_src[i++] = DI.Port3_air.para6.userautomodesetting;
				t_src[i++] = DI.Port3_air.para7.opmode;
				t_src[i++] = DI.Port3_air.para15.ddp;
				t_src[2] = i-3; // 待记忆实体个数   
				datatmp=fCRC16_cal(&t_src[3], t_src[2]);
				t_src[i++] = datatmp>>8;
				t_src[i++] = datatmp&0xff;
				if(Sys.Factoryflg==0) //非工厂检测状态才会记忆
				{
					R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
					fFLASH_WRITE(FLASH_BLOCK2_SYSSTATUS_8000,&t_src[0],i); //系统数据写入FLASH_BLOCK2_SYSSTATUS_8000  经常改变
				}
				R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
			}
			R_GPT_Stop(&Timer_125us_ctrl);
			R_WDT_Refresh(&g_wdt_ctrl); //WDT 刷新
		}
		
		PWR_MOTOR_EN();  // 加快放电
		LED_Ring_En();
		PWR_WIFI_EN();
		PWR_PM25_EN();
	}
	
}
void interrupt_irq0_PM25(external_irq_callback_args_t * p_args)
{
	if(1 == Pin_CheckPM25)
	{
		Particle.P1Flag = 0;//
	}
	else
	{
		Particle.P1Flag = 1;//低电平才开始计数
	}

}


void g_Timer_125us(timer_callback_args_t * p_args)  //12US左右的执行时间
{

	fFanFeedBackCalc();  // 风速计算
	if(Sys.Factoryflg)
	{
		if(0 == Pin_CheckPM25)
		{
			Particle.P1Time++;
		}
	
	}
	#if PM25LIB
	{
		u8 static Cnt=0;
		if(Sys.Factoryflg == 0)
		{
			Cnt++;
			if(Cnt>=4)  //使用PM2.5库的话 每500us使用
			{
				Cnt = 0;
				pmScan(Pin_CheckPM25);
			}
		}
	}
	#else
	{
		if(0 == Pin_CheckPM25)
		{
			Particle.P1Time++;
		}
	}
	#endif
	#ifndef TEST
  	fDisp_LedDriver();
	#endif
}


void user_uart_callback(uart_callback_args_t * p_args)
{
	R_SCI_UART_Read(&g_uart2_ctrl, &tRxBuffer[0],RTxData_Max);  //最多150个数据
}




/*******************************************************************************************************************//**
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 **********************************************************************************************************************/
void R_BSP_WarmStart (bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif
